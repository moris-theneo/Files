type Account {
	accountNumber: String
	apr: Float
	apy: Float
	availableBalance: Float
	availableCredit: Float
	balance: Float
	cashBalance: Float
	cashSurrenderValue: Float
	createdAt: DateTime
	creditLimit: Float
	currencyCode: String
	dayPaymentIsDue: Int
	deathBenefit: Float
	guid: String
	holdingsValue: Float
	id: String
	importedAt: DateTime
	institutionCode: String
	insuredName: String
	interestRate: Float
	isClosed: Boolean
	isHidden: Boolean
	lastPayment: Float
	lastPaymentAt: DateTime
	loanAmount: Float
	maturesOn: DateTime
	memberGuid: String
	memberId: String
	memberIsManagedByUser: Boolean
	metadata: String
	minimumBalance: Float
	minimumPayment: Float
	name: String
	nickname: String
	originalBalance: Float
	payOutAmount: Float
	paymentDueAt: DateTime
	payoffBalance: Float
	premiumAmount: Float
	routingNumber: String
	startedOn: DateTime
	subtype: String
	totalAccountValue: Float
	type: String
	updatedAt: DateTime
	userGuid: String
	userId: String
}

type AccountsList {
	accounts: [Account!]!
	pagination: Pagination!
}

"""
Aliases for coins and providers as used by other services and APIs
"""
type Alias {
	"""
	The unique identifier for this alias
	"""
	uuid: UUID!
	"""
	The data source where the alias is used
	"""
	source: String!
	"""
	The unique identifier for the alias within the source
	"""
	id: String
	"""
	The human-readable name of the alias at the source
	"""
	name: String
	"""
	The unique human-readable internal identifier of the alias at the source
	"""
	slug: String
	"""
	The symbol used by the source to represent the alias in order books
	"""
	symbol: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	providersAlias(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [ProvidersAlias!]!
}

"""
Builder for [`Alias`](struct.Alias.html).
"""
input AliasInput {
	"""
	The unique identifier for this alias
	"""
	uuid: UUID
	"""
	The data source where the alias is used
	"""
	source: String
	"""
	The unique identifier for the alias within the source
	"""
	id: String
	"""
	The human-readable name of the alias at the source
	"""
	name: String
	"""
	The unique human-readable internal identifier of the alias at the source
	"""
	slug: String
	"""
	The symbol used by the source to represent the alias in order books
	"""
	symbol: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type AliasPayload {
	action: String!
	payload: Alias
	error: String
}

type Amount {
	min: Numeric
	max: Numeric
}

"""
Symmetrically encrypted api keys that belong to the user at certain providers
"""
type ApiKey {
	"""
	The unique identifier for the api key
	"""
	uuid: UUID!
	"""
	The account name for the api key
	"""
	account: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The id of the user role that has ownership over the api key
	"""
	roleId: UUID
	"""
	The date the api key was last used in a request
	"""
	requestedAt: DateTime
	"""
	The date the api key was last used and received a successful response
	"""
	successAt: DateTime
	"""
	The type of token provided by the api key, OAUTH or API_KEY
	"""
	type: String
	"""
	The date the api key or token expires, if applicable
	"""
	expiry: DateTime
	"""
	The unique identifier for the user-tracked provider at Hedgehog
	"""
	usersProvidersId: UUID!
	"""
	The unique identifier for the user that owns the api key
	"""
	userId: UUID!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UsersProvider!]!
}

"""
The ApiKey entity as it should be passed to and from the Node service to take advantage of the key vault
"""
type ApiKeyNode {
	"""
	The unique identifier for the api key
	"""
	uuid: UUID!
	"""
	(Deprecated) The account name for the api key
	"""
	account: String
	"""
	(Deprecated) The public key for the api key
	"""
	key: String!
	"""
	The secret key for the api key, if provided
	"""
	secret: Secret
	"""
	The password for the api key, if required
	"""
	password: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The id of the user role that has ownership over the api key
	"""
	roleId: UUID
	"""
	The date the api key was last used in a request
	"""
	requestedAt: DateTime
	"""
	The date the api key was last used and received a successful response
	"""
	successAt: DateTime
	"""
	The type of token provided by the api key, OAUTH or API_KEY
	"""
	type: String!
	"""
	The date the api key or token expires, if applicable
	"""
	expiry: DateTime
	"""
	The unique identifier for the api key at the data source, if provided
	"""
	apiUid: String
	"""
	The unique identifier for the user-tracked provider at Hedgehog
	"""
	usersProvidersId: UUID!
	"""
	The unique identifier for the user that owns the api key
	"""
	userId: UUID!
}

"""
Builder for [`ApiKeyNode`](struct.ApiKeyNode.html).
"""
input ApiKeyNodeInput {
	"""
	The unique identifier for the api key
	"""
	uuid: UUID
	"""
	(Deprecated) The account name for the api key
	"""
	account: String
	"""
	(Deprecated) The public key for the api key
	"""
	key: String
	"""
	The secret key for the api key, if provided
	"""
	secret: SecretInput
	"""
	The password for the api key, if required
	"""
	password: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The id of the user role that has ownership over the api key
	"""
	roleId: UUID
	"""
	The date the api key was last used in a request
	"""
	requestedAt: DateTime
	"""
	The date the api key was last used and received a successful response
	"""
	successAt: DateTime
	"""
	The type of token provided by the api key, OAUTH or API_KEY
	"""
	type: String
	"""
	The date the api key or token expires, if applicable
	"""
	expiry: DateTime
	"""
	The unique identifier for the api key at the data source, if provided
	"""
	apiUid: String
	"""
	The unique identifier for the user-tracked provider at Hedgehog
	"""
	usersProvidersId: UUID
	"""
	The unique identifier for the user that owns the api key
	"""
	userId: UUID
}

type ApiKeyPayload {
	action: String!
	payload: ApiKey
	error: String
}

"""
A user's personal connection to a coin for tracking purposes
"""
type Asset {
	"""
	The unique identifier for this asset
	"""
	uuid: UUID!
	"""
	Whether the user has hearted this asset
	"""
	isHearted: Boolean!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier for the coin being tracked by the user
	"""
	coinId: UUID!
	"""
	The unique identifier for the user tracking the asset
	"""
	userId: UUID!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
Builder for [`Asset`](struct.Asset.html).
"""
input AssetInput {
	"""
	The unique identifier for this asset
	"""
	uuid: UUID
	"""
	Whether the user has hearted this asset
	"""
	isHearted: Boolean
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The unique identifier for the coin being tracked by the user
	"""
	coinId: UUID
	"""
	The unique identifier for the user tracking the asset
	"""
	userId: UUID
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
}

type AssetPayload {
	action: String!
	payload: Asset
	error: String
}

"""
Builder for [`AssetsAverageBalanceRequest`](struct.AssetsAverageBalanceRequest.html).
"""
input AssetsAverageBalanceRequestInput {
	userId: UUID
	startDate: String
	endDate: String
}

type AssetsAverageBalanceResponse {
	userId: UUID!
	frequency: String!
	startDate: String!
	endDate: String!
	averageBalanceUsd: String!
}

"""
An aggregate view of the balances associated with a given asset within a user's holdings,
eg, all the BTC balances in belonging to Jon Hope
"""
type AssetsV {
	"""
	The user-tracked asset's unique identifier
	"""
	assetId: UUID
	"""
	The unique identifier for the user tracking the asset
	"""
	userId: UUID
	"""
	The unique identifier for the coin being tracked by the user
	"""
	coinId: UUID
	"""
	The human-readable unique identifier for the coin being tracked by the user
	"""
	coinInternalId: String
	"""
	The symbol generally representing the coin in order books
	"""
	coinSymbol: String
	"""
	The coin order for the associated coin
	"""
	coinOrder: Int
	"""
	Whether the user has hearted the asset
	"""
	isHearted: Boolean
	"""
	The sum of all balances associated with the asset which are owned by the user
	"""
	balance: Numeric
	"""
	The sum of all balances associated with the asset which are owned by the user, in USD
	"""
	balanceUsd: Numeric
	"""
	The current known exchange rate of the coin to USD
	"""
	fxRateUsd: Numeric
	"""
	The total number of balances associated with the asset which are owned by the user
	"""
	balanceCount: Int
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	marketCandle(where: Where, limit: Int! = 0, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [MarketCandle!]!
	marketLatestMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [MarketLatestMetrics!]!
	marketMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [MarketMetric!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

type AumErrorForUser {
	userId: UUID!
	error: String!
}

type AumFee {
	"""
	The unique identifier for the AUM fee record
	"""
	uuid: UUID!
	"""
	The user associated with the transaction
	"""
	userId: UUID!
	"""
	The subscription belonging to the user when the AUM fee was charged
	"""
	subscriptionId: UUID
	"""
	The date representing the AUM charge month
	"""
	aumDate: NaiveDate!
	"""
	The fee amount in USD
	"""
	amountUsd: Numeric!
	"""
	The user's average monthly managed asset balance for the month indicated by aum_date
	"""
	averageBalanceUsd: Numeric!
	"""
	The AUM rate used to compute the fee. This rate is multiplied by average_balance_usd to calculate amount_usd.
	"""
	aumRate: Numeric!
	"""
	The status of the fee charge (one of success, in_progress, error)
	"""
	status: String!
	"""
	The deposit transaction ID used to fund the AUM fee into the user's custodial account
	"""
	depositTransactionId: UUID
	"""
	The payment transaction ID representing funds moved from the user's custodial account to the Hedgehog internal account
	"""
	paymentTransactionId: UUID
	"""
	The human-readable reason for failure, if applicable.
	"""
	errorMessage: String
	"""
	The error code, if applicable.
	"""
	errorCode: String
	"""
	Arbitrary JSON structure containing details on the error, if applicable.
	"""
	errorDetails: JSON
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
A record of a user's holdings for a particular address-provider-coin-network-contract-status combination.
Eg, a user may have a free balance of 1.0 ETH on the mainnet, 0.1 ETH staked on the Ropsten testnet, and 0.5 WETH pending on Solana
on the same public address being tracked via Metamask and Ledger Nano X.
"""
type Balance {
	"""
	The unique identifier for this balance
	"""
	uuid: UUID!
	"""
	The user friendly name for this balance
	"""
	addressName: String!
	"""
	The current balance amount
	"""
	balance: Numeric!
	"""
	The associated public address or bank routing number for this balance
	"""
	address: String
	"""
	The associated address tag when applicable, or bank account number for this balance
	"""
	addressTag: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier for the stack associated with this balance
	"""
	stackId: UUID!
	"""
	The unique identifier for the user associated with this balance
	"""
	userId: UUID!
	"""
	The unique identifier for the role controlling this balance
	"""
	roleId: UUID
	"""
	Whether or not the address is valid
	"""
	isValid: Boolean!
	"""
	The date the balance was last synced with the blockchain, DLT network, or host institution
	"""
	lastSyncedAt: DateTime
	"""
	The unique identifier for the coin associated with this balance
	"""
	coinId: UUID!
	"""
	The unique identifier for the provider associated with this balance
	"""
	providerId: UUID!
	"""
	The unique identifier at Gemini for this address
	"""
	geminiAddressLabel: String
	"""
	The status of the withdrawal whitelisting request at Gemini, if applicable
	"""
	geminiWithdrawalAddressStatus: String
	"""
	The current status of the balance, eg. pending, free, staked
	"""
	status: String
	"""
	Whether or not the balance is hidden from the user
	"""
	isHidden: Boolean!
	"""
	Whether or not the balance is the primary balance for the user that should receive undesignated funds when deposits are recognized
	"""
	isPrimary: Boolean!
	"""
	Whether or not the balance is a funding source for the user that should be used to fund transactions
	"""
	isFundingSource: Boolean!
	"""
	Whether or not the balance is an external balance that is not owned by the user, but is being tracked for the user
	"""
	isExternal: Boolean!
	"""
	The unique identifier for the smart contract associated with this balance, if applicable
	"""
	contractId: UUID
	"""
	The unique identifier for the payment network associated with this balance, if applicable
	"""
	networkId: UUID
	"""
	The unique identifier for the user-tracked provider associated with this balance
	"""
	usersProvidersId: UUID!
	"""
	The unique identifier for the MX account associated with this balance, if applicable
	"""
	mxAccountId: UUID
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	"""
	The unique identifier for the Plaid account associated with this balance, if applicable
	"""
	plaidAccountId: UUID
	"""
	Indicates whether a balance is custodial or not, helping to differentiate between balances managed internally or externally.
	"""
	isManaged: Boolean!
	balancesV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [BalancesV!]!
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	network(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_asc"]): [Network!]!
	provider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [Provider!]!
	stack(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_asc"]): [Stack!]!
	transfers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Transfer!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
Builder for [`Balance`](struct.Balance.html).
"""
input BalanceInput {
	"""
	The unique identifier for this balance
	"""
	uuid: UUID
	"""
	The user friendly name for this balance
	"""
	addressName: String
	"""
	The current balance amount
	"""
	balance: Numeric
	"""
	The associated public address or bank routing number for this balance
	"""
	address: String
	"""
	The associated address tag when applicable, or bank account number for this balance
	"""
	addressTag: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The unique identifier for the stack associated with this balance
	"""
	stackId: UUID
	"""
	The unique identifier for the user associated with this balance
	"""
	userId: UUID
	"""
	The unique identifier for the role controlling this balance
	"""
	roleId: UUID
	"""
	Whether or not the address is valid
	"""
	isValid: Boolean
	"""
	The date the balance was last synced with the blockchain, DLT network, or host institution
	"""
	lastSyncedAt: DateTime
	"""
	The unique identifier for the coin associated with this balance
	"""
	coinId: UUID
	"""
	The unique identifier for the provider associated with this balance
	"""
	providerId: UUID
	"""
	The unique identifier at Gemini for this address
	"""
	geminiAddressLabel: String
	"""
	The status of the withdrawal whitelisting request at Gemini, if applicable
	"""
	geminiWithdrawalAddressStatus: String
	"""
	The current status of the balance, eg. pending, free, staked
	"""
	status: String
	"""
	Whether or not the balance is hidden from the user
	"""
	isHidden: Boolean
	"""
	Whether or not the balance is the primary balance for the user that should receive undesignated funds when deposits are recognized
	"""
	isPrimary: Boolean
	"""
	Whether or not the balance is a funding source for the user that should be used to fund transactions
	"""
	isFundingSource: Boolean
	"""
	Whether or not the balance is an external balance that is not owned by the user, but is being tracked for the user
	"""
	isExternal: Boolean
	"""
	The unique identifier for the smart contract associated with this balance, if applicable
	"""
	contractId: UUID
	"""
	The unique identifier for the payment network associated with this balance, if applicable
	"""
	networkId: UUID
	"""
	The unique identifier for the user-tracked provider associated with this balance
	"""
	usersProvidersId: UUID
	"""
	The unique identifier for the MX account associated with this balance, if applicable
	"""
	mxAccountId: UUID
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	"""
	The unique identifier for the Plaid account associated with this balance, if applicable
	"""
	plaidAccountId: UUID
	"""
	Indicates whether a balance is custodial or not, helping to differentiate between balances managed internally or externally.
	"""
	isManaged: Boolean
}

type BalanceMovementResults {
	debitBalance: Balance!
	creditBalance: Balance!
	transaction: Transaction!
}

type BalanceOrderTransaction {
	balances: [Balance!]!
	orders: [Order!]!
	transactions: [Transaction!]!
}

type BalancePayload {
	action: String!
	payload: Balance
	error: String
}

"""
A table to connect balances and labels for the purpose of filtering or tagging when reconciling accounting
"""
type BalancesLabel {
	"""
	The unique identifier for this balance label
	"""
	uuid: UUID!
	"""
	The unique identifier for the associated balance
	"""
	balanceId: UUID!
	"""
	The unique identifier for the associated label
	"""
	labelId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	balance(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Balance!]!
	label(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Label!]!
}

"""
Builder for [`BalancesLabel`](struct.BalancesLabel.html).
"""
input BalancesLabelInput {
	"""
	The unique identifier for this balance label
	"""
	uuid: UUID
	"""
	The unique identifier for the associated balance
	"""
	balanceId: UUID
	"""
	The unique identifier for the associated label
	"""
	labelId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type BalancesLabelPayload {
	action: String!
	payload: BalancesLabel
	error: String
}

"""
Builder for [`BalancesSyncRequest`](struct.BalancesSyncRequest.html).
"""
input BalancesSyncRequestInput {
	userId: UUID
	addressIds: [UUID!]
	providerIds: [UUID!]
}

"""
A view of balances that converts the relevant balance to a USD equivalent
"""
type BalancesV {
	"""
	The unique identifier for this balance
	"""
	balanceId: UUID!
	"""
	The user friendly name for this balance
	"""
	addressName: String!
	"""
	The current balance amount
	"""
	balance: Numeric!
	"""
	The associated public address or bank routing number for this balance
	"""
	address: String
	"""
	The associated address tag when applicable, or bank account number for this balance
	"""
	addressTag: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier for the stack associated with this balance
	"""
	stackId: UUID!
	"""
	The unique identifier for the user associated with this balance
	"""
	userId: UUID!
	"""
	The unique identifier for the role controlling this balance
	"""
	roleId: UUID
	"""
	Whether or not the address is valid
	"""
	isValid: Boolean!
	"""
	The date the balance was last synced with the blockchain, DLT network, or host institution
	"""
	lastSyncedAt: DateTime
	"""
	The unique identifier for the coin associated with this balance
	"""
	coinId: UUID!
	"""
	The human-readable unique identifier for the coin associated with this balance
	"""
	coinInternalId: String
	"""
	The unique identifier for the provider associated with this balance
	"""
	providerId: UUID!
	"""
	The human-readable unique identifier for the provider associated with this balance
	"""
	providerInternalId: String
	"""
	The unique identifier for the MX account associated with this balance
	"""
	mxId: String
	"""
	The type of MX account associated with this balance, eg CHECKING, SAVINGS, CREDIT
	"""
	mxAccountType: String
	"""
	The ID of the provider in the Plaid database, used to identify banks and other traditional financial institutions
	"""
	plaidExternalInstitutionId: String
	"""
	The unique identifier for the Plaid account associated with this balance, if applicable
	"""
	plaidAccountId: UUID
	"""
	The unique identifier at Gemini for this address
	"""
	geminiAddressLabel: String
	"""
	The status of the withdrawal whitelisting request at Gemini, if applicable
	"""
	geminiWithdrawalAddressStatus: String
	"""
	The current status of the balance, eg. pending, free, staked
	"""
	status: String
	"""
	Whether or not the balance is hidden from the user
	"""
	isHidden: Boolean!
	"""
	The unique identifier for the smart contract associated with this balance, if applicable
	"""
	contractId: UUID
	"""
	The unique identifier for the payment network associated with this balance, if applicable
	"""
	networkId: UUID
	"""
	The unique identifier for the user-tracked provider associated with this balance
	"""
	usersProvidersId: UUID!
	"""
	Whether or not the balance is a funding source for the user that should be used to fund transactions
	"""
	isFundingSource: Boolean!
	"""
	Whether or not the balance is the primary balance for the user that should receive undesignated funds when deposits are recognized
	"""
	isPrimary: Boolean!
	"""
	Whether or not the balance is an external balance that is not owned by the user, but is being tracked for the user
	"""
	isExternal: Boolean!
	"""
	The current balance amount in USD
	"""
	balanceUsd: Numeric
	"""
	The current known exchange rate of the coin to USD
	"""
	fxRateUsd: Numeric
	"""
	Indicates whether a balance is custodial or not, helping to differentiate between balances managed internally or externally.
	"""
	isManaged: Boolean!
	"""
	The unique identifier for the portfolio associated with this balance
	"""
	portfolioId: UUID!
	balances(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Balance!]!
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	network(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_asc"]): [Network!]!
	provider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [Provider!]!
	stack(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_asc"]): [Stack!]!
	credits(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Transaction!]!
	debits(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Transaction!]!
	usersProvider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UsersProvider!]!
	usersProvidersV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [UsersProvidersV!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
Builder for [`BaseEmailRequest`](struct.BaseEmailRequest.html).
"""
input BaseEmailRequestInput {
	userId: String
	email: String
}


"""
Builder for [`BuyStackRequest`](struct.BuyStackRequest.html).
"""
input BuyStackRequestInput {
	userId: UUID
	stackId: UUID
	amount: String
	excludeCoinInternalIds: [String!]
	basisCoinInternalId: String
	forceRebalance: Boolean
}

type CcxtExchanges {
	data: JSON!
	type: String!
	url: String!
}

type CcxtExchangesPayload {
	action: String!
	payload: CcxtExchanges
	error: String
}

type CcxtMarket {
	providerId: UUID
	id: String
	symbol: String
	base: String
	quote: String
	baseId: String
	quoteId: String
	active: Boolean
	type: String
	spot: Boolean
	margin: Boolean
	future: Boolean
	swap: Boolean
	option: Boolean
	contract: Boolean
	settle: String
	settleId: String
	contractSize: Numeric
	linear: Boolean
	inverse: Boolean
	expiry: DateTime
	expiryDatetime: DateTime
	strike: Numeric
	optionType: String
	taker: Numeric
	maker: Numeric
	percentage: Boolean
	tierBased: Boolean
	feeSide: String
	precision: Precision
	limits: Limits
	info: JSON
}

type CcxtMarketPayload {
	action: String!
	payload: CcxtMarket
	error: String
}

type CcxtMarketsByProvider {
	data: JSON!
	providerId: UUID!
	type: String!
	url: String!
}

type CcxtMarketsByProviderPayload {
	action: String!
	payload: CcxtMarketsByProvider
	error: String
}

"""
Builder for [`CcxtRequest`](struct.CcxtRequest.html).
"""
input CcxtRequestInput {
	userId: UUID
	providerId: UUID
	type: String
	fromSymbol: String
	toSymbol: String
	apiKeyId: UUID
	orderId: UUID
	externalId: String
	since: String
	limit: String
	baseCoinId: UUID
	quoteCoinId: UUID
	networkId: UUID
	contractId: UUID
	orderType: String
	isShort: Boolean
	price: String
	amount: String
	source: String
	sourceTs: String
	symbols: [String!]
}

type ChargeMonthlyAumFeeAllResult {
	aumFees: [AumFee!]!
	errors: [AumErrorForUser!]!
}

"""
A CiText type is a case insensitive text field useful for ensuring unique strings. Postgres' native email type implements case insensitive text
"""
scalar CiText

"""
The model containing high level identifiers for every tradeable and trackable asset on Hedgehog.
"""
type Coin {
	"""
	The unique identifier for this coin.
	"""
	uuid: UUID!
	"""
	The human-readable name of the coin.
	"""
	name: String!
	"""
	The order in which the coin should be displayed in lists.
	"""
	order: Int
	"""
	The type of coin, e.g. 'CRYPTO', 'FIAT', 'STABLECOIN'.
	"""
	type: String
	"""
	The date the coin was launched.
	"""
	launch: NaiveDate
	"""
	The icon to use for the coin.
	"""
	icon: String!
	"""
	The symbol generally used to represent the coin in order books.
	"""
	symbol: String!
	"""
	The number of significant figures supported by the coin protocol.
	"""
	sigfigs: Int
	"""
	The default asset class to use when creating a new asset of this coin.
	"""
	defaultAssetClass: String
	"""
	Any system-wide notifications to display when viewing this coin.
	"""
	notifications: JSON!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The human-readable internal identifier for the coin, used for urls.
	"""
	internalId: String
	"""
	Whether the coin is actively being developed.
	"""
	isActive: Boolean!
	"""
	Whether the coin is currently supported on any exchange or liquidity pool.
	"""
	isTrading: Boolean!
	"""
	Whether the coin should be hidden from display.
	"""
	isHidden: Boolean!
	"""
	The unique identifier for the color to use when displaying the coin.
	"""
	colorId: UUID!
	colors(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [String!]!
	coinsCryptoGroups(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [CoinsCryptoGroup!]!
	coinOfferings(where: Where, limit: Int! = 0, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [CoinOffering!]!
	coinPairs(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [CoinPair!]!
	coinResearch(where: Where, limit: Int! = 0, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [CoinResearch!]!
	baseFxRatesUsd(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [FxLatestUsdRatesV!]!
	quoteFxRatesUsd(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [FxLatestUsdRatesV!]!
	baseFxRates(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [FxRatesV!]!
	quoteFxRates(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [FxRatesV!]!
	marketCandle(where: Where, limit: Int! = 0, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [MarketCandle!]!
	marketLatestMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [MarketLatestMetrics!]!
	marketMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [MarketMetric!]!
	topExchanges(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["volume_24h_usd_desc"]): [MarketTopExchange!]!
	topExchangesBase(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["volume_24h_usd_desc"]): [MarketTopExchangesV!]!
	topExchangesQuote(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["volume_24h_usd_desc"]): [MarketTopExchangesV!]!
	topPairsBase(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["volume_24h_usd_desc"]): [MarketTopPairsV!]!
	topPairsQuote(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["volume_24h_usd_desc"]): [MarketTopPairsV!]!
	panels(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Panel!]!
	wallets(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Wallet!]!
	walletsV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["coin_internal_id_desc"]): [WalletsV!]!
}

"""
Builder for [`Coin`](struct.Coin.html).
"""
input CoinInput {
	"""
	The unique identifier for this coin.
	"""
	uuid: UUID
	"""
	The human-readable name of the coin.
	"""
	name: String
	"""
	The order in which the coin should be displayed in lists.
	"""
	order: Int
	"""
	The type of coin, e.g. 'CRYPTO', 'FIAT', 'STABLECOIN'.
	"""
	type: String
	"""
	The date the coin was launched.
	"""
	launch: NaiveDate
	"""
	The icon to use for the coin.
	"""
	icon: String
	"""
	The symbol generally used to represent the coin in order books.
	"""
	symbol: String
	"""
	The number of significant figures supported by the coin protocol.
	"""
	sigfigs: Int
	"""
	The default asset class to use when creating a new asset of this coin.
	"""
	defaultAssetClass: String
	"""
	Any system-wide notifications to display when viewing this coin.
	"""
	notifications: JSON
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The human-readable internal identifier for the coin, used for urls.
	"""
	internalId: String
	"""
	Whether the coin is actively being developed.
	"""
	isActive: Boolean
	"""
	Whether the coin is currently supported on any exchange or liquidity pool.
	"""
	isTrading: Boolean
	"""
	Whether the coin should be hidden from display.
	"""
	isHidden: Boolean
	"""
	The unique identifier for the color to use when displaying the coin.
	"""
	colorId: UUID
}

"""
Information about the initial offering of a coin
"""
type CoinOffering {
	"""
	The unique identifier for this coin offering
	"""
	uuid: UUID!
	"""
	Whether the offering is closed
	"""
	closed: Boolean
	"""
	The platform the offering was hosted on
	"""
	platform: String!
	"""
	The date the offering started
	"""
	start: NaiveDate!
	"""
	The date the offering ended
	"""
	end: NaiveDate!
	"""
	The allocation of tokens to various groups
	"""
	tokenAllocation: JSON!
	"""
	The currency the offering was priced in
	"""
	currency: String
	"""
	The price of the initial offering
	"""
	price: String
	"""
	The amount raised in the offering
	"""
	raised: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The type of offering, eg ICO, private
	"""
	type: String!
	"""
	The amounts received in each currency
	"""
	fundingSources: JSON
	"""
	The unique identifier of the associated coin offered
	"""
	coinId: UUID
	coins(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
}

type CoinOfferingPayload {
	action: String!
	payload: CoinOffering
	error: String
}

"""
A a pair of coins that can be traded on a provider.
"""
type CoinPair {
	"""
	The unique identified of the base coin in the pair
	"""
	fromCoinId: UUID
	"""
	The unique identified of the quote coin in the pair
	"""
	toCoinId: UUID
	"""
	The unique identified of the provider that the pair is traded on
	"""
	providerId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier for this coin pair
	"""
	uuid: UUID!
	baseCoin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	quoteCoin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	provider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [Provider!]!
}

"""
Builder for [`CoinPair`](struct.CoinPair.html).
"""
input CoinPairInput {
	"""
	The unique identified of the base coin in the pair
	"""
	fromCoinId: UUID
	"""
	The unique identified of the quote coin in the pair
	"""
	toCoinId: UUID
	"""
	The unique identified of the provider that the pair is traded on
	"""
	providerId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The unique identifier for this coin pair
	"""
	uuid: UUID
}

type CoinPairPayload {
	action: String!
	payload: CoinPair
	error: String
}

type CoinPayload {
	action: String!
	payload: Coin
	error: String
}

"""
Research associated with a token protocol including supply, blocktime, throughput, etc.
"""
type CoinResearch {
	"""
	The name of the algorithm used to encrypt blocks or vote on transaction validity
	"""
	algorithm: String
	"""
	The type of proof used to validate blocks and messages
	"""
	proofType: String
	"""
	The maximum supply of the token protocol
	"""
	supplyLimit: String
	"""
	The amount of tokens pre-mined by the protocol before the genesis transaction
	"""
	preMinedSupply: Int
	"""
	The value of the pre-mined tokens in USD
	"""
	preMinedValue: Int
	"""
	The current total supply of the token protocol, including locked tokens
	"""
	totalSupply: Int
	"""
	The current total supply of the token protocol available to retail buyers
	"""
	totalFloat: Int
	"""
	A short description of the token protocol
	"""
	logline: String
	"""
	The average time between blocks
	"""
	blocktime: String
	"""
	The average number of transactions per second
	"""
	throughput: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier of the associated coin
	"""
	coinId: UUID!
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
}

type CoinResearchPayload {
	action: String!
	payload: CoinResearch
	error: String
}

"""
Connects coins table to contracts table, as a coin may have multiple contracts associated with it,
eg, ETH on Ethereum, Polygon, Solana networks may all have different contract hashes
"""
type CoinsContract {
	"""
	The unique identifier for this coin-contract association
	"""
	uuid: UUID!
	"""
	The unique identifier of the associated coin
	"""
	coinId: UUID!
	"""
	The unique identifier of the associated contract
	"""
	contractId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	Whether this is the default contract for the coin
	"""
	isDefault: Boolean!
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	contracts(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Contract!]!
}

"""
A view joining the associated contracts onto a coin
"""
type CoinsContractsV {
	"""
	The unique identifier of the associated coin
	"""
	coinId: UUID
	"""
	The symbol of the associated coin
	"""
	symbol: String
	"""
	The human-readable unique identifier of the associated coin
	"""
	internalId: String
	"""
	The unique identifier of the associated contract
	"""
	contractId: UUID
	"""
	The human-readable name of the associated contract
	"""
	contractName: String
	"""
	The public address of the associated smart contract
	"""
	contractAddress: String
	"""
	The unique identifier of the associated network where the contract is deployed
	"""
	networkId: UUID
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	contracts(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Contract!]!
	network(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_asc"]): [Network!]!
}

"""
Connects groups of companies or people to a coin
"""
type CoinsCryptoGroup {
	"""
	The unique identifier for this coin-group association
	"""
	uuid: UUID!
	"""
	The unique identifier for the associated coin
	"""
	coinId: UUID
	"""
	The unique identifier for the associated crypto group
	"""
	cryptoGroupId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	cryptoGroups(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [CryptoGroup!]!
	coins(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
}

type CoinsCryptoGroupPayload {
	action: String!
	payload: CoinsCryptoGroup
	error: String
}

"""
A list of colors and gradients that are associated with coins, providers, and portfolios
"""
type Color {
	"""
	The unique identifier for this color
	"""
	uuid: UUID!
	"""
	The first color in the gradient
	"""
	color1: String
	"""
	The second color in the gradient
	"""
	color2: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The human-readable name of the color for client display and selection purposes
	"""
	name: String
}

"""
Builder for [`Color`](struct.Color.html).
"""
input ColorInput {
	"""
	The unique identifier for this color
	"""
	uuid: UUID
	"""
	The first color in the gradient
	"""
	color1: String
	"""
	The second color in the gradient
	"""
	color2: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The human-readable name of the color for client display and selection purposes
	"""
	name: String
}

type ColorPayload {
	action: String!
	payload: Color
	error: String
}

"""
Builder for [`ContactSupportErrorRequest`](struct.ContactSupportErrorRequest.html).
"""
input ContactSupportErrorRequestInput {
	incidentId: UUID
	errorMessage: String
	page: String
	controller: String
	method: String
	time: DateTime
	ipAddress: String
	buildVersion: String
	userId: UUID
	userAgent: String
	contactMessage: String
	otherData: JSON
}

"""
Builder for [`ContactSupportRequest`](struct.ContactSupportRequest.html).
"""
input ContactSupportRequestInput {
	userId: UUID
	email: String
	subject: String
	message: String
	buildVersion: String
	userAgent: String
	incidentId: UUID
}

type ContactSupportResponse {
	message: String!
}

"""
Copywritten content that is contained in a panel. This will eventually be replaced by contenful calls
"""
type Content {
	"""
	The unique identifier for the content
	"""
	uuid: UUID!
	"""
	The type of content. This will be used to determine how to render it
	"""
	type: String!
	"""
	Any source link associated with the content
	"""
	link: String
	"""
	The order of the content in the panel
	"""
	order: Int!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier of the associated panel
	"""
	panelId: UUID
	elements(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Element!]!
}

type ContentPayload {
	action: String!
	payload: Content
	error: String
}

"""
Information associated with the smart contract representing a currency on a given network
"""
type Contract {
	"""
	The unique identifier for the contract
	"""
	uuid: UUID!
	"""
	The name of the contract
	"""
	contractName: String!
	"""
	The public address of the contract
	"""
	address: String!
	"""
	The unique identifier of the network the contract is deployed on
	"""
	networkId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	networks(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_asc"]): [Network!]!
}

"""
Builder for [`Contract`](struct.Contract.html).
"""
input ContractInput {
	"""
	The unique identifier for the contract
	"""
	uuid: UUID
	"""
	The name of the contract
	"""
	contractName: String
	"""
	The public address of the contract
	"""
	address: String
	"""
	The unique identifier of the network the contract is deployed on
	"""
	networkId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type ContractPayload {
	action: String!
	payload: Contract
	error: String
}

"""
Countries and their country codes with regulatory availability
"""
type Country {
	"""
	The unique identifier for the country
	"""
	uuid: UUID!
	"""
	The name of the country
	"""
	countryName: String!
	"""
	The two character country code
	"""
	twoCharCountryCode: String!
	"""
	Whether or not the country is available to customers for regulatory compliance
	"""
	isHedgehogAvailable: Boolean
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
}

type CreatePlaidPublicTokenResponse {
	expiration: DateTime!
	linkToken: String!
	requestId: String!
}

type CryptoDeposit {
	transaction: Transaction!
	creditAddress: String!
}

"""
A person, company, or foundation that is connected with a coin
"""
type CryptoEntity {
	"""
	The unique identifier for the entity
	"""
	uuid: UUID!
	"""
	The name of the entity
	"""
	name: String!
	"""
	The image of the entity
	"""
	image: String!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	cryptoMember(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [CryptoMember!]!
}

type CryptoEntityPayload {
	action: String!
	payload: CryptoEntity
	error: String
}

"""
A group of entities connected with a coin
"""
type CryptoGroup {
	"""
	The unique identifier for the group
	"""
	uuid: UUID!
	"""
	The name of the group
	"""
	name: String!
	"""
	The type of the group, eg Founders, Directors, News, Development
	"""
	type: String!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The panel that the group belongs to
	"""
	panelId: UUID
	coinCryptoGroup(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [CoinsCryptoGroup!]!
	cryptoMember(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [CryptoMember!]!
	panels(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Panel!]!
}

type CryptoGroupPayload {
	action: String!
	payload: CryptoGroup
	error: String
}

"""
Associates a CryptoEntity with a CryptoGroup
"""
type CryptoMember {
	"""
	The type of the member, Supporter, QA Team Member, Virtual Reality
	"""
	type: String!
	"""
	The time the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The time the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The group that the member belongs to
	"""
	cryptoGroupId: UUID
	"""
	The entity that the belongs to the group
	"""
	cryptoEntityId: UUID
	"""
	The link describing the member
	"""
	linkId: UUID
	"""
	The unique identifier for the member
	"""
	uuid: UUID!
	cryptoEntity(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [CryptoEntity!]!
	cryptoGroup(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [CryptoGroup!]!
	link(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_asc"]): [Link!]!
}

type CryptoMemberPayload {
	action: String!
	payload: CryptoMember
	error: String
}

"""
Implement the DateTime<Utc> scalar

The input/output is a string in RFC3339 format.
"""
scalar DateTime

"""
Builder for [`DefaultStackRecommendationRequest`](struct.DefaultStackRecommendationRequest.html).
"""
input DefaultStackRecommendationRequestInput {
	userId: UUID
}

type DefaultStackRecommendationResponse {
	stack: StackDefaultsConfig!
}

"""
The elements inside of Content blocks, basically representing paragraphs. This will eventually be replaced by contentful calls
"""
type Element {
	"""
	The unique identifier for the element
	"""
	uuid: UUID!
	"""
	The type of the element which determines the render, eg content-group, subtitle
	"""
	type: String!
	"""
	The text associated with the parent content
	"""
	text: String!
	"""
	Any link associated with the source of the content
	"""
	link: String
	"""
	The order in which the elements should be rendered within the content block
	"""
	order: Int!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier for the parent content block
	"""
	contentId: UUID
	content(where: Where, limit: Int! = 20, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Content!]!
}

type ElementPayload {
	action: String!
	payload: Element
	error: String
}

"""
A list of feature for use in feature flags and user interest signups
"""
type Feature {
	"""
	The unique identifier for the feature
	"""
	uuid: UUID!
	"""
	The name of the feature
	"""
	name: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
}

"""
Builder for [`Feature`](struct.Feature.html).
"""
input FeatureInput {
	"""
	The unique identifier for the feature
	"""
	uuid: UUID
	"""
	The name of the feature
	"""
	name: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type FeaturePayload {
	action: String!
	payload: Feature
	error: String
}

"""
any fees associated with a transaction, order, transfer, or any other more granular representation
"""
type Fee {
	"""
	The unique identifier for the fee
	"""
	uuid: UUID!
	"""
	The unique identifier of the user associated with the fee
	"""
	userId: UUID!
	"""
	The percent rate of the fee
	"""
	rate: Numeric!
	"""
	The tip portion of the fee given to the miner
	"""
	tip: Numeric!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
}

type FeePayload {
	action: String!
	payload: Fee
	error: String
}


"""
A view exposing the most recent fx rate data for each coin and the implied or actual price in USD
"""
type FxLatestUsdRatesV {
	"""
	The unique identifier for the fx rate
	"""
	uuid: UUID
	"""
	The timestamp of the fx rate data given by the source
	"""
	sourceTs: DateTime
	"""
	The source provider of the fx rate data
	"""
	source: String
	"""
	The ascending order priority indicating the reliability source provider of the fx rate data
	"""
	sourcePriority: Int
	"""
	The base symbol of the fx rate, usually given base/quote. In the pair BTC/USD the base would be BTC
	"""
	baseSymbol: String
	"""
	The quote symbol of the fx rate, usually given base/quote. In the pair BTC/USD the base would be USD
	"""
	quoteSymbol: String
	"""
	The venue where the fx rate was quoted, AGG is an aggregate measure
	"""
	provider: String
	"""
	The price in USD of one token of the base symbol
	"""
	price: Numeric
	"""
	The total volume on the base_coin
	"""
	volume: Numeric
	"""
	The volume on the base_coin in the last 24 hours
	"""
	volume24H: Numeric
	"""
	The price in USD of one token of the base symbol at the start of the day
	"""
	open24H: Numeric
	"""
	The highest price in USD of one token of the base symbol in the last 24 hours
	"""
	high24H: Numeric
	"""
	The lowest price in USD of one token of the base symbol in the last 24 hours
	"""
	low24H: Numeric
	"""
	The USD change in price of one token of the base symbol in the last 24 hours
	"""
	change24H: Numeric
	"""
	The percentage change in price in USD of one token of the base symbol in the last 24 hours
	"""
	changePercent: Numeric
	"""
	The all time high price in USD of one token of the base symbol
	"""
	athPrice: Numeric
	"""
	The date of the all time high price
	"""
	athDate: DateTime
	"""
	The percentage decrease in price from the all time high
	"""
	percentFromPriceAth: Numeric
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The unique identifier for the base coin
	"""
	baseCoinId: UUID
	"""
	The unique identifier for the quote coin, ie USD
	"""
	quoteCoinId: UUID
	"""
	The unique identifier for the associated provider
	"""
	providerId: UUID
	"""
	The row number for the row in the view
	"""
	rn: Int
	baseCoin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	quoteCoin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	providers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [Provider!]!
}

"""
Fx rate data for each coin exposing prices and candle metrics
"""
type FxRate {
	"""
	The unique identifier for the fx rate
	"""
	uuid: UUID!
	"""
	The timestamp of the fx rate data given by the source
	"""
	sourceTs: DateTime!
	"""
	The source provider of the fx rate data
	"""
	source: String!
	"""
	The ascending order priority indicating the reliability source provider of the fx rate data
	"""
	sourcePriority: Int!
	"""
	The base symbol of the fx rate, usually given base/quote. In the pair BTC/ETH the base would be BTC
	"""
	baseSymbol: String!
	"""
	The quote symbol of the fx rate, usually given base/quote. In the pair BTC/ETH the base would be ETH
	"""
	quoteSymbol: String!
	"""
	The price of one token of the base symbol quoted in the quote symbol
	"""
	price: Numeric!
	"""
	The venue where the fx rate was quoted, AGG is an aggregate measure
	"""
	provider: String
	"""
	The total volume on the pair
	"""
	volume: Numeric
	"""
	The volume on the pair in the last 24 hours
	"""
	volume24H: Numeric
	"""
	The price in the quote symbol of one token of the base symbol at the start of the day
	"""
	open24H: Numeric
	"""
	The highest price in the quote symbol of one token of the base symbol in the last 24 hours
	"""
	high24H: Numeric
	"""
	The lowest price in the quothe symbol of one token of the base symbol in the last 24 hours
	"""
	low24H: Numeric
	"""
	The change in price of one token of the base symbol as quoted in the quote symbol in the last 24 hours
	"""
	change24H: Numeric
	"""
	The percentage change in price in one token of the base symbol quoted in the quote symbol in the last 24 hours
	"""
	changePercent: Numeric
	"""
	The all time high price in the quote symbol of one token of the base symbol
	"""
	athPrice: Numeric
	"""
	The date of the all time high price
	"""
	athDate: DateTime
	"""
	The percentage decrease in price from the all time high
	"""
	percentFromPriceAth: Numeric
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
}

"""
Builder for [`FxRate`](struct.FxRate.html).
"""
input FxRateInput {
	"""
	The unique identifier for the fx rate
	"""
	uuid: UUID
	"""
	The timestamp of the fx rate data given by the source
	"""
	sourceTs: DateTime
	"""
	The source provider of the fx rate data
	"""
	source: String
	"""
	The ascending order priority indicating the reliability source provider of the fx rate data
	"""
	sourcePriority: Int
	"""
	The base symbol of the fx rate, usually given base/quote. In the pair BTC/ETH the base would be BTC
	"""
	baseSymbol: String
	"""
	The quote symbol of the fx rate, usually given base/quote. In the pair BTC/ETH the base would be ETH
	"""
	quoteSymbol: String
	"""
	The price of one token of the base symbol quoted in the quote symbol
	"""
	price: Numeric
	"""
	The venue where the fx rate was quoted, AGG is an aggregate measure
	"""
	provider: String
	"""
	The total volume on the pair
	"""
	volume: Numeric
	"""
	The volume on the pair in the last 24 hours
	"""
	volume24H: Numeric
	"""
	The price in the quote symbol of one token of the base symbol at the start of the day
	"""
	open24H: Numeric
	"""
	The highest price in the quote symbol of one token of the base symbol in the last 24 hours
	"""
	high24H: Numeric
	"""
	The lowest price in the quothe symbol of one token of the base symbol in the last 24 hours
	"""
	low24H: Numeric
	"""
	The change in price of one token of the base symbol as quoted in the quote symbol in the last 24 hours
	"""
	change24H: Numeric
	"""
	The percentage change in price in one token of the base symbol quoted in the quote symbol in the last 24 hours
	"""
	changePercent: Numeric
	"""
	The all time high price in the quote symbol of one token of the base symbol
	"""
	athPrice: Numeric
	"""
	The date of the all time high price
	"""
	athDate: DateTime
	"""
	The percentage decrease in price from the all time high
	"""
	percentFromPriceAth: Numeric
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type FxRatePayload {
	action: String!
	payload: FxRate
	error: String
}

"""
A view exposing the most recent fx rate data for each coin along with connections to the relevant coins and provider
"""
type FxRatesV {
	"""
	The unique identifier for the fx rate
	"""
	uuid: UUID
	"""
	The timestamp of the fx rate data given by the source
	"""
	sourceTs: DateTime
	"""
	The source provider of the fx rate data
	"""
	source: String
	"""
	The ascending order priority indicating the reliability source provider of the fx rate data
	"""
	sourcePriority: Int
	"""
	The base symbol of the fx rate, usually given base/quote. In the pair BTC/ETH the base would be BTC
	"""
	baseSymbol: String
	"""
	The quote symbol of the fx rate, usually given base/quote. In the pair BTC/ETH the base would be ETH
	"""
	quoteSymbol: String
	"""
	The venue where the fx rate was quoted, AGG is an aggregate measure
	"""
	provider: String
	"""
	The price of one token of the base symbol quoted in the quote symbol
	"""
	price: Numeric
	"""
	The total volume on the pair
	"""
	volume: Numeric
	"""
	The volume on the pair in the last 24 hours
	"""
	volume24H: Numeric
	"""
	The price in the quote symbol of one token of the base symbol at the start of the day
	"""
	open24H: Numeric
	"""
	The highest price in the quote symbol of one token of the base symbol in the last 24 hours
	"""
	high24H: Numeric
	"""
	The lowest price in the quothe symbol of one token of the base symbol in the last 24 hours
	"""
	low24H: Numeric
	"""
	The change in price of one token of the base symbol as quoted in the quote symbol in the last 24 hours
	"""
	change24H: Numeric
	"""
	The percentage change in price in one token of the base symbol quoted in the quote symbol in the last 24 hours
	"""
	changePercent: Numeric
	"""
	The all time high price in the quote symbol of one token of the base symbol
	"""
	athPrice: Numeric
	"""
	The date of the all time high price
	"""
	athDate: DateTime
	"""
	The percentage decrease in price from the all time high
	"""
	percentFromPriceAth: Numeric
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The unique identifier for the base coin
	"""
	baseCoinId: UUID
	"""
	The unique identifier for the quote coin, ie USD
	"""
	quoteCoinId: UUID
	"""
	The unique identifier for the associated provider
	"""
	providerId: UUID
	baseCoin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	quoteCoin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	providers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [Provider!]!
}

"""
The necessary components to find a user's custodial gemini account
"""
type GeminiAccount {
	"""
	The unique identifier for the gemini account
	"""
	uuid: UUID!
	"""
	The name of the account
	"""
	accountName: String
	"""
	The unique identifier of the user associated with the gemini account
	"""
	userId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

type GeminiAccountPayload {
	action: String!
	payload: GeminiAccount
	error: String
}

type GeminiFeeEstimate {
	currency: String!
	value: String!
}

type GeminiTrade {
	account: String!
	amount: String!
	price: String!
	timestampms: Int!
	side: String!
	isAggressor: Boolean!
	feeAssetCode: String!
	feeAmount: String!
	orderId: Int!
	exchange: String!
	isAuctionFill: Boolean!
	isClearingFill: Boolean!
	symbol: String!
}

type GeminiTransactionsReturn {
	trades: [GeminiTrade!]!
	transfers: [GeminiTransfer!]!
	continuationToken: String
}

type GeminiTransfer {
	timestampms: Int!
	source: String!
	destination: String!
	operationReason: String!
	status: String!
	eid: Int!
	currency: String!
	amount: String!
	method: String!
	correlationId: Int!
	transferType: String!
	bankId: String
	purpose: String
	transactionHash: String
	transferId: String
	withdrawalId: String
	clientTransferId: String
	advanceEid: Int
	pendingEid: Int
	withdrawalEid: Int
	feeId: String
}

type GeminiUser {
	name: String!
	lastSignIn: String!
	status: String!
	countryCode: String!
	isVerified: Boolean!
}

type GeminiUserAccount {
	accountName: String!
	shortName: String!
	type: String!
	created: String!
}

type GetAccountDetailResponse {
	account: GeminiUserAccount!
	users: [GeminiUser!]!
	memoReferenceCode: String!
}

type GetAllAccountsResponseAccount {
	name: String!
	account: String!
	type: String!
	counterpartyId: String
	created: Int!
}

type GetAvailableBalancesResponseBalance {
	currency: String!
	amount: String!
	available: String!
	availableForWithdrawal: String!
	type: String!
}

type GetDepositAddressesResponseAddress {
	network: String
	address: String!
	label: String
	memo: String
}

type GetGasFeeEstimateSuccess {
	currency: String!
	fee: GeminiFeeEstimate!
	isOverride: Boolean!
	monthlyLimit: Int!
	monthlyRemaining: Int!
}

type GetNetworkResponse {
	token: String!
	network: [String!]!
}

type GetPastTradesResponse {
	price: String!
	amount: String!
	timestamp: Int!
	timestampms: Int!
	type: String!
	aggressor: Boolean!
	feeCurrency: String!
	feeAmount: String!
	tid: Int!
	orderId: String!
	clientOrderId: String
	exchange: String!
	isAuctionFill: Boolean!
	isClearingFill: Boolean!
	symbol: String!
	tradeBroken: String
}

type GetPriceFeedItem {
	pair: String!
	price: String!
	percentChange24H: String!
}

type GetSymbolDetailsResponse {
	symbol: String!
	baseCurrency: String!
	quoteCurrency: String!
	tickSize: Float!
	quoteIncrement: Float!
	minOrderSize: String!
	status: String!
	wrapEnabled: Boolean!
}

type GetTickerResponse {
	symbol: String
	open: String
	high: String
	low: String
	close: String
	changes: [String!]
	bid: String
	ask: String
}

type GetTransfersResponseTransfer {
	type: String!
	status: String!
	timestampms: Int!
	eid: Int!
	advanceId: Int
	currency: String!
	amount: String!
	feeAmount: String
	feeCurrency: String
	method: String
	txHash: String
	withdrawalId: Int
	outputIdx: Int
	destination: String
	purpose: String
}



"""
A scalar that can represent any JSON value.
"""
scalar JSON

"""
Metadata tags for other connected tables
"""
type Label {
	"""
	The unique identifier for the label
	"""
	uuid: UUID!
	"""
	The name of the label
	"""
	name: String!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
}

"""
Builder for [`Label`](struct.Label.html).
"""
input LabelInput {
	"""
	The unique identifier for the label
	"""
	uuid: UUID
	"""
	The name of the label
	"""
	name: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type LabelPayload {
	action: String!
	payload: Label
	error: String
}

type Limits {
	amount: Amount
	price: JSON
	cost: JSON
	leverage: JSON
}

"""
Used by crypto members to denote a reference link
"""
type Link {
	"""
	The unique identifier for the link
	"""
	uuid: UUID!
	"""
	The url of the link
	"""
	url: String!
	"""
	The type of the link, eg youtube, twitter, etc
	"""
	type: String!
	"""
	A description of the link
	"""
	description: String
	"""
	A list of relevant feeds that can be scraped with RSS
	"""
	feeds: [String!]
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	cryptoMember(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [CryptoMember!]!
}

type LinkBankInstitutionViaPlaidResponse {
	usersProvidersId: UUID!
	plaidMembersId: UUID!
	providerId: UUID!
	providerName: String!
	newAccountsLinked: Int!
}

"""
Builder for [`Link`](struct.Link.html).
"""
input LinkInput {
	"""
	The unique identifier for the link
	"""
	uuid: UUID
	"""
	The url of the link
	"""
	url: String
	"""
	The type of the link, eg youtube, twitter, etc
	"""
	type: String
	"""
	A description of the link
	"""
	description: String
	"""
	A list of relevant feeds that can be scraped with RSS
	"""
	feeds: [String!]
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type LinkPayload {
	action: String!
	payload: Link
	error: String
}

"""
Builder for [`ListForUserRequest`](struct.ListForUserRequest.html).
"""
input ListForUserRequestInput {
	userGuid: String
	page: Int
	recordsPerPage: Int
}

"""
A live price to be broadcast directly from Nifi over Kafka to the client
"""
type LivePrice {
	sourceTs: DateTime
	source: String
	sourcePriority: Int!
	baseSymbol: String
	quoteSymbol: String
	price: Numeric
	provider: String
	baseCoinId: UUID
	quoteCoinId: UUID
	providerId: String
	volume: Numeric
	volume24H: Numeric
	open24H: Numeric
	high24H: Numeric
	low24H: Numeric
	change24H: Numeric
	changePercent: Numeric
	athPrice: Numeric
	athDate: DateTime
	percentFromPriceAth: Numeric
}

type LivePricePayload {
	action: String!
	payload: LivePrice
	error: String
}

type Lot {
	"""
	The unique identifier for the lot
	"""
	uuid: UUID!
	"""
	The unique identifier of the user associated with the lot
	"""
	userId: UUID!
	"""
	The unique identifier of the child transfer associated with the lot
	"""
	transferId: UUID!
	"""
	The unique identifier of the parent transfer associated with the lot
	"""
	parentTransferId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	transfer(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Transfer!]!
	parentTransfer(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Transfer!]!
}

type LotPayload {
	action: String!
	payload: Lot
	error: String
}

"""
Market candle data for each coin exposing prices and candle metrics
"""
type MarketCandle {
	"""
	The unique identifier for the associated coin
	"""
	coinId: UUID!
	"""
	The timestamp of the candle data given by the source
	"""
	sourceTs: DateTime!
	"""
	The source provider of the candle data
	"""
	source: String!
	"""
	The ascending priority order of the source provider
	"""
	sourcePriority: Int!
	"""
	The frequency of the candle data, ie HOUR, DAY, WEEK, MONTH, YEAR
	"""
	frequency: String!
	"""
	The opening price at the beginning of the candle period
	"""
	priceOpenUsd: Numeric
	"""
	The closing price at the end of the candle period
	"""
	priceCloseUsd: Numeric!
	"""
	The highest price over the candle period
	"""
	priceHighUsd: Numeric
	"""
	The lowest price over the candle period
	"""
	priceLowUsd: Numeric
	"""
	The total trading volume during the candle period
	"""
	volumeUsd: Numeric
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
}

"""
Builder for [`MarketCandle`](struct.MarketCandle.html).
"""
input MarketCandleInput {
	"""
	The unique identifier for the associated coin
	"""
	coinId: UUID
	"""
	The timestamp of the candle data given by the source
	"""
	sourceTs: DateTime
	"""
	The source provider of the candle data
	"""
	source: String
	"""
	The ascending priority order of the source provider
	"""
	sourcePriority: Int
	"""
	The frequency of the candle data, ie HOUR, DAY, WEEK, MONTH, YEAR
	"""
	frequency: String
	"""
	The opening price at the beginning of the candle period
	"""
	priceOpenUsd: Numeric
	"""
	The closing price at the end of the candle period
	"""
	priceCloseUsd: Numeric
	"""
	The highest price over the candle period
	"""
	priceHighUsd: Numeric
	"""
	The lowest price over the candle period
	"""
	priceLowUsd: Numeric
	"""
	The total trading volume during the candle period
	"""
	volumeUsd: Numeric
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type MarketCandlePayload {
	action: String!
	payload: MarketCandle
	error: String
}

"""
A model that aggregates the total market cap and other metrics of interest for the universe of coins
"""
type MarketCapLatestTotals {
	"""
	The unique identifier for this record
	"""
	uuid: UUID!
	"""
	The total market cap in USD
	"""
	totalMarketCapUsd: Numeric
	"""
	The total 24 hour volume in USD
	"""
	total24HVolumeUsd: Numeric
	"""
	The total market cap in BTC
	"""
	totalMarketCapBtc: Numeric
	"""
	The total 24 hour volume in BTC
	"""
	total24HVolumeBtc: Numeric
	"""
	The total market cap in ETH
	"""
	totalMarketCapEth: Numeric
	"""
	The total 24 hour volume in ETH
	"""
	total24HVolumeEth: Numeric
	"""
	The percentage of the total market cap that BTC represents
	"""
	btcPercentOfTotalMarketCap: Numeric
	"""
	The percentage of the total market cap that ETH represents
	"""
	ethPercentOfTotalMarketCap: Numeric
	"""
	The percentage of the total market cap that the top 10 coins represent
	"""
	top10PercentOfTotalMarketCap: Numeric
	"""
	The percentage of the total market cap that ERC20 tokens represent
	"""
	erc20PercentOfTotalMarketCap: Numeric
	"""
	The total number of coins in the universe
	"""
	totalCoins: Numeric
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
}

"""
The total market capitalization and 24h volume for over a given time frequency
"""
type MarketCapTotals {
	"""
	The unique identifier for this market cap snapshot
	"""
	uuid: UUID!
	"""
	The time frequency for this market cap snapshot
	"""
	frequency: String!
	"""
	The timestamp for this market cap snapshot
	"""
	sourceTs: DateTime!
	"""
	The total market cap in USD
	"""
	totalMarketCapUsd: Numeric
	"""
	The total 24h volume in USD
	"""
	total24HVolumeUsd: Numeric
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
}

"""
MarketLatestMetrics holds the latest metrics attached to any given coin.
These are collected from a variety of sources, including CoinMarketCap, CryptoCompare, CoinMetrics,
Santiment, Dune Analytics, and others
"""
type MarketLatestMetrics {
	"""
	The unique identifier for this metrics record
	"""
	uuid: UUID!
	"""
	The unique identifier for the coin this metrics record is attached to
	"""
	coinId: UUID!
	"""
	The number of unique active addresses for this coin in the last 24 hours
	"""
	activeAddresses: Numeric
	"""
	The average hash rate for this coin in the last 24 hours
	"""
	averageHashRate: Numeric
	"""
	The average block size for this coin in the last 24 hours
	"""
	blockAverageSize: Numeric
	"""
	The number of blocks mined for this coin in the last 24 hours
	"""
	blockCount: Numeric
	"""
	The number of developer code commits on this coin in the last 24 hours
	"""
	devActivity: Numeric
	"""
	The inflation rate for this coin in the last 24 hours
	"""
	inflationRate: Numeric
	"""
	The market cap denominated in USD for this coin in the last 24 hours
	"""
	marketCapUsd: Numeric
	"""
	The number of tokens minted for this coin in the last 24 hours
	"""
	minted: Numeric
	"""
	The USD value of tokens minted for this coin in the last 24 hours
	"""
	mintedUsd: Numeric
	"""
	The market value of the token divided by the price of each token the last time it was moved.
	Generally this is an indicator of how much profit people could take by selling today.
	"""
	mvrv: Numeric
	"""
	The network value divided by the daily transaction volume
	"""
	nvtAdj: Numeric
	"""
	The network value divided by the daily transaction volume, averaged over the last 90 days
	"""
	nvtAdjRolling90DAvg: Numeric
	"""
	The market cap of the coin in USD if it were valued at the price each token was last moved at.
	"""
	realizedMarketCapUsd: Numeric
	"""
	The return on investment of the coin over the last year
	"""
	roi1Yr: Numeric
	"""
	The return on investment of the coin over the last year averaged over the last 30 days
	"""
	roi30D: Numeric
	"""
	The average number of tokens that would be minted on this day if block minting were deterministic
	"""
	scheduledMinted: Numeric
	"""
	The USD value of the average number of tokens that would be minted on this day if block minting were deterministic
	"""
	scheduledMintedUsd: Numeric
	"""
	The number of tokens in circulation in the last 24 hours
	"""
	supply: Numeric
	"""
	The total number of tokens that were transferred between wallets in the last 24 hours, adjusted for wash transfers
	"""
	txAdjTransferValue: Numeric
	"""
	The total USD value of tokens that were transferred between wallets in the last 24 hours, adjusted for wash transfers
	"""
	txAdjTransferValueUsd: Numeric
	"""
	The average fee paid for a transaction on this coin in the last 24 hours
	"""
	txAverageFee: Numeric
	"""
	The average USD value of the fee paid for a transaction on this coin in the last 24 hours
	"""
	txAverageFeeUsd: Numeric
	"""
	The average USD value of the tokens transferred between wallets in the last 24 hours
	"""
	txAverageTransferValue: Numeric
	"""
	The average USD value of the tokens transferred between wallets in the last 24 hours
	"""
	txAverageTransferValueUsd: Numeric
	"""
	The number of transactions on this coin in the last 24 hours, including transfers and swaps
	"""
	txCount: Numeric
	"""
	The median fee paid for a transaction on this coin in the last 24 hours
	"""
	txMedianFee: Numeric
	"""
	The median USD value of the fee paid for a transaction on this coin in the last 24 hours
	"""
	txMedianFeeUsd: Numeric
	"""
	The median number of tokens transferred between wallets in the last 24 hours
	"""
	txMedianTransferValue: Numeric
	"""
	The median USD value of the tokens transferred between wallets in the last 24 hours
	"""
	txMedianTransferValueUsd: Numeric
	"""
	The total fees paid over the last 24 hours
	"""
	txTotalFees: Numeric
	"""
	The total USD value of fees paid over the last 24 hours
	"""
	txTotalFeesUsd: Numeric
	"""
	The total number of tokens that were transferred between wallets in the last 24 hours
	"""
	txTransferCount: Numeric
	"""
	The 180 day volatility, or variance, of the token
	"""
	volatility180D: Numeric
	"""
	The 30 day volatility, or variance, of the token
	"""
	volatility30D: Numeric
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
}

"""
Individual metrics for tokens on a given source timestamp date
"""
type MarketMetric {
	"""
	The unique identifier for the associated coin
	"""
	coinId: UUID!
	"""
	The timestamp of the metric data given by the source
	"""
	sourceTs: DateTime!
	"""
	The source provider of the metric data
	"""
	source: String!
	"""
	The ascending priority order of data quality for the source provider on this metric
	"""
	sourcePriority: Int!
	"""
	The frequency of the metric data, ie HOUR, DAY, WEEK, MONTH, YEAR
	"""
	frequency: String!
	"""
	The name of the metric, ie market_cap_usd, volume_usd, etc
	"""
	metric: String
	"""
	The value of the metric
	"""
	metricValue: Numeric!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
}

"""
Builder for [`MarketMetric`](struct.MarketMetric.html).
"""
input MarketMetricInput {
	"""
	The unique identifier for the associated coin
	"""
	coinId: UUID
	"""
	The timestamp of the metric data given by the source
	"""
	sourceTs: DateTime
	"""
	The source provider of the metric data
	"""
	source: String
	"""
	The ascending priority order of data quality for the source provider on this metric
	"""
	sourcePriority: Int
	"""
	The frequency of the metric data, ie HOUR, DAY, WEEK, MONTH, YEAR
	"""
	frequency: String
	"""
	The name of the metric, ie market_cap_usd, volume_usd, etc
	"""
	metric: String
	"""
	The value of the metric
	"""
	metricValue: Numeric
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type MarketMetricPayload {
	action: String!
	payload: MarketMetric
	error: String
}

"""
The top exchanges for a given coin by volume
"""
type MarketTopExchange {
	"""
	The unique identifier for this top exchanges record
	"""
	uuid: UUID!
	"""
	The unique identifier for the coin
	"""
	coinId: UUID!
	"""
	The timestamp of the source data
	"""
	sourceTs: DateTime!
	"""
	The source of the data
	"""
	source: String!
	"""
	The ascending order priority of the source, and indicator of data reliability
	"""
	sourcePriority: Int!
	"""
	The period over which the data was aggregated and analyzed
	"""
	frequency: String!
	"""
	The exchange name
	"""
	exchange: String!
	"""
	The base symbol in the exchange pair, eg in BTC/ETH the base symbol is BTC
	"""
	baseSymbol: String!
	"""
	The quote symbol in the exchange pair, eg in BTC/ETH the quote symbol is ETH
	"""
	quoteSymbol: String!
	"""
	The volume of the base currency in the exchange pair in the last 24 hours
	"""
	volume24HBaseCurrency: Numeric!
	"""
	The exchange grade, an indicator of the exchanges reliability in reporting real market data
	"""
	exchangeGrade: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
}

"""
Builder for [`MarketTopExchange`](struct.MarketTopExchange.html).
"""
input MarketTopExchangeInput {
	"""
	The unique identifier for this top exchanges record
	"""
	uuid: UUID
	"""
	The unique identifier for the coin
	"""
	coinId: UUID
	"""
	The timestamp of the source data
	"""
	sourceTs: DateTime
	"""
	The source of the data
	"""
	source: String
	"""
	The ascending order priority of the source, and indicator of data reliability
	"""
	sourcePriority: Int
	"""
	The period over which the data was aggregated and analyzed
	"""
	frequency: String
	"""
	The exchange name
	"""
	exchange: String
	"""
	The base symbol in the exchange pair, eg in BTC/ETH the base symbol is BTC
	"""
	baseSymbol: String
	"""
	The quote symbol in the exchange pair, eg in BTC/ETH the quote symbol is ETH
	"""
	quoteSymbol: String
	"""
	The volume of the base currency in the exchange pair in the last 24 hours
	"""
	volume24HBaseCurrency: Numeric
	"""
	The exchange grade, an indicator of the exchanges reliability in reporting real market data
	"""
	exchangeGrade: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type MarketTopExchangePayload {
	action: String!
	payload: MarketTopExchange
	error: String
}

type MarketTopExchangesV {
	"""
	The unique identifier for this top exchanges record
	"""
	uuid: UUID
	"""
	The unique identifier for the top pair
	"""
	topPairId: UUID
	"""
	The unique identifier for the base coin
	"""
	baseCoinId: UUID
	"""
	The unique identifier for the quote coin
	"""
	quoteCoinId: UUID
	"""
	The timestamp of the source data
	"""
	sourceTs: DateTime
	"""
	The source of the data
	"""
	source: String
	"""
	The exchange the data is referencing
	"""
	exchange: String
	"""
	The unique identifier for the provider
	"""
	providerId: UUID
	"""
	The base symbol of the pair
	"""
	baseSymbol: String
	"""
	The quote symbol of the pair
	"""
	quoteSymbol: String
	"""
	The 24 hour volume in the base currency
	"""
	volume24HBaseCurrency: Numeric
	"""
	The 24 hour volume in USD
	"""
	volume24HUsd: Numeric
	"""
	The reliability of the exchange in reporting real market data
	"""
	exchangeGrade: String
	"""
	The rank of the exchange in terms of reliable volume
	"""
	exchangeRank: Int
	base(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	quote(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	provider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [Provider!]!
}

"""
A view exposing the top pairs for a given exchange
"""
type MarketTopPairsV {
	"""
	The unique identifier for this top pairs record
	"""
	uuid: UUID!
	"""
	The unique identifier for the associated base coin
	"""
	baseCoinId: UUID!
	"""
	The unique identifier for the associated quote coin
	"""
	quoteCoinId: UUID!
	"""
	The timestamp of the source data
	"""
	sourceTs: DateTime!
	"""
	The source of the data
	"""
	source: String!
	"""
	The time period frequency of the data entry
	"""
	frequency: String!
	"""
	The exchange name
	"""
	exchange: String!
	"""
	The base symbol in the pair
	"""
	baseSymbol: String!
	"""
	The quote symbol in the pair
	"""
	quoteSymbol: String!
	"""
	The 24 hour volume in the base currency
	"""
	volume24HBaseCurrency: Numeric!
	"""
	The 24 hour volume in USD
	"""
	volume24HUsd: Numeric
	"""
	The rank of the pair by volume
	"""
	pairRank: Int!
	base(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	quote(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
}

type Member {
	guid: String!
	id: String
	userGuid: String!
	userId: String!
	aggregatedAt: DateTime!
	backgroundAggregationIsDisabled: Boolean!
	institutionCode: String!
	isBeingAggregated: Boolean!
	isManagedByUser: Boolean!
	isOauth: Boolean!
	metadata: String
	name: String!
	successfullyAggregatedAt: DateTime!
	connectionStatus: String!
}

type MembersList {
	members: [Member!]!
	pagination: Pagination!
}

type Mutation {
	geminiWithdrawCrypto(userId: UUID!, address: String!, amount: Numeric!, coinSymbol: String!, memo: String, clientTransferId: String): WithdrawalResponse!
	getOrCreateGeminiAccount(userId: UUID!): GeminiAccount!
	getGeminiAccountDetails(userId: UUID!): GetAccountDetailResponse!
	getAllAccountsFromGemini: [GetAllAccountsResponseAccount!]!
	getGeminiAvailableBalances(userId: UUID!): [GetAvailableBalancesResponseBalance!]!
	getGeminiPaymentMethods(userId: UUID!): PaymentMethods!
	getGeminiCandles(geminiSymbol: String!, timeFrame: String!): [[Numeric!]!]!
	getGeminiDepositAddresses(network: String!, timestamp: DateTime, userId: UUID!): [GetDepositAddressesResponseAddress!]!
	getGeminiGasFeeEstimate(userId: UUID!, symbol: String!, address: String!, amount: Numeric!): GetGasFeeEstimateSuccess!
	getGeminiOrderStatus(userId: UUID!, orderId: UUID!): Order!
	getAllPendingGeminiOrderStatus(userId: UUID!): [Order!]!
	getAndUpsertGeminiTrades(userId: UUID!, timestamp: DateTime, limit: Int, ingestFullHistory: Boolean): [Order!]!
	getGeminiTrades(userId: UUID!, coinSymbol: String, timestamp: DateTime, limit: Int): [GetPastTradesResponse!]!
	getGeminiTransactions(timestamp: DateTime, limit: Int, continuationToken: String): GeminiTransactionsReturn!
	getGeminiTransfers(userId: UUID!, coinSymbol: String, timestamp: DateTime, limit: Int): [GetTransfersResponseTransfer!]!
	getGeminiTransactionStatus(userId: UUID!, transactionId: UUID!): Transaction!
	getAndUpsertGeminiTransactions(userId: UUID!, timestamp: DateTime, limit: Int, ingestDeposits: Boolean, ingestWithdrawals: Boolean, ingestFullHistory: Boolean): [Transaction!]!
	geminiBalancesPurgeAndSync(userId: UUID!): BalanceOrderTransaction!
	getGeminiNetwork(coinSymbol: String!): GetNetworkResponse!
	getGeminiPriceFeed: [GetPriceFeedItem!]!
	getGeminiSymbols: [String!]!
	getGeminiSymbolDetails(geminiSymbol: String!): GetSymbolDetailsResponse!
	getGeminiTicker(geminiSymbol: String!): GetTickerResponse!
	updateBalanceWithDepositAddress(userId: UUID!, balanceId: UUID!): Balance!
	removeWhitelistWithdrawalAddress(address: String!, network: String!, userId: UUID!): String!
	getWhitelistedAddresses(network: String!, userId: UUID!): [WhitelistedAddress!]!
	whitelistWithdrawalAddress(address: String!, network: String!, userId: UUID!, addressName: String): String!
	upsertSuitability(userId: UUID!, answerId: UUID!): Suitability!
	depositCrypto(idempotencyKey: String!, userId: UUID!, debitBalanceId: UUID!, amount: Numeric!, creditBalanceId: UUID, comment: String, txHash: String, networkId: UUID, contractId: UUID): CryptoDeposit!
	reportCanceledTransaction(userId: UUID!, transactionId: UUID!): Transaction!
	reportFailedTransaction(userId: UUID!, transactionId: UUID!): Transaction!
	hideTransaction(userId: UUID!, transactionId: UUID!): Transaction!
	withdrawCrypto(idempotencyKey: String!, userId: UUID!, creditBalanceAddress: String!, creditBalanceMemo: String, coinInternalId: String!, amount: Numeric!, debitBalanceId: UUID): Transaction!
	createCustodialOrder(idempotencyKey: String!, userId: UUID!, creditCoinId: UUID!, debitCoinId: UUID!, amount: Numeric!, slippage: Numeric! = "0.001000000", stackId: UUID, creditBalanceId: UUID, debitBalanceId: UUID): Order!
	scheduleRecurringCustodialOrder(idempotencyKey: String!, userId: UUID!, creditCoinId: UUID!, debitCoinId: UUID!, amount: Numeric!, slippage: Numeric! = "0.001000000", stackId: UUID, creditBalanceId: UUID, debitBalanceId: UUID, startDate: DateTime!, schedule: String!, repetitions: Int): OrderScheduleAndOrders!
	executeRecurringCustodialOrder(idempotencyKey: String!, userId: UUID!, orderScheduleId: UUID!): OrderScheduleAndOrders!
	hideOrder(userId: UUID!, orderId: UUID!): Order!
	moveBalanceToStack(idempotencyKey: String!, userId: UUID!, debitBalanceId: UUID!, creditStackId: UUID!, amount: Numeric!): BalanceMovementResults!
	makeStackDefault(userId: UUID!, stackId: UUID!): Stack!
	transferBalance(idempotencyKey: String!, userId: UUID!, creditBalanceId: UUID!, debitBalanceId: UUID!, amount: Numeric!): Transaction!
	liquidateCustodialStack(idempotencyKey: String!, userId: UUID!, stackId: UUID!, excludeCoinInternalIds: [String!]!, creditCoinInternalId: String!, amount: Numeric!, isPercentage: Boolean!): [Order!]!
	planRebalanceStack(idempotencyKey: String!, input: RebalanceStackRequestInput!): [Order!]!
	buyCustodialStack(idempotencyKey: String!, input: BuyStackRequestInput!): [Order!]!
	rebalanceCustodialStack(idempotencyKey: String!, input: RebalanceStackRequestInput!): [Order!]!
	saveUserCountry(userId: UUID!, countryId: UUID!): UserDetail!
	mxUserFetchOrCreate(userId: UUID!): MxUser!
	listMxAccounts(input: ListForUserRequestInput!, userId: UUID!): AccountsList!
	listMxMembers(input: ListForUserRequestInput!, userId: UUID!): MembersList!
	requestMxWidgetUrl(input: WidgetUrlRequestInput!, userId: UUID!): WidgetUrlResponse!
	ccxtPublicAsync(input: CcxtRequestInput!): JSON!
	ccxtPublicSync(input: CcxtRequestInput!): JSON!
	ccxtPrivateAsync(input: CcxtRequestInput!): JSON!
	ccxtPrivateSync(input: CcxtRequestInput!): JSON!
	syncBalances(input: BalancesSyncRequestInput!): String!
	nodeConnectionTest: String!
	getDefaultStackRecommendation(input: DefaultStackRecommendationRequestInput!): DefaultStackRecommendationResponse!
	getUserAssetsGraph(input: UserAssetsGraphRequestInput!): UserAssetsGraphResponse!
	getPortfolioGraph(input: PortfolioGraphRequestInput!): PortfolioGraphResponse!
	getStackGraph(input: StackGraphRequestInput!): StackGraphResponse!
	getAssetsAverageBalance(input: AssetsAverageBalanceRequestInput!): AssetsAverageBalanceResponse!
	getPortfolioWeightsById(input: PortfolioWeightRequestInput!): PortfolioWeight!
	getStackWeightsById(input: StackWeightRequestInput!): StackWeight!
	getStackAssetWeightById(input: StackAssetWeightRequestInput!): StackAssetWeight!
	getTotalReturn(input: TotalReturnRequestInput!): TotalReturnResponse!
	getTotalReturnComparison(input: TotalReturnComparisonRequestInput!): TotalReturnComparisonResponse!
	getPortfolioMinDeposit(input: PortfolioMinDepositRequestInput!): PortfolioMinDepositResponse!
	validateAddress(input: ValidateAddressRequestInput!): ValidateAddressResponse!
	addStackDefaultToUserPortfolio(userId: UUID!, portfolioId: UUID!, stackDefaultsConfigId: UUID!, excludeCoinInternalIds: [String!]! = []): Stack!
	contactSupportError(input: ContactSupportErrorRequestInput!): ContactSupportResponse!
	contactSupport(input: ContactSupportRequestInput!): ContactSupportResponse!
	requestAccountDeletion(input: BaseEmailRequestInput!): ContactSupportResponse!
	sendDisqualifiedNotification(input: BaseEmailRequestInput!): ContactSupportResponse!
	sendLegalDocs(input: BaseEmailRequestInput!): ContactSupportResponse!
	sendProfitAndLoss(input: ProfitLossEmailRequestInput!): ContactSupportResponse!
	createOutsideInstrumentBank(userId: UUID!, mxUserGuid: String!, mxAccountGuid: String!): QoloOutsideInstrument!
	createOutsideInstrumentCard: String!
	qoloPersonFetchOrCreate(userId: UUID!, userFirstName: String!, userLastName: String!): QoloPerson!
	devPopulateHedgehogGeminiBalances: String!
	depositFiat(idempotencyKey: String!, userId: UUID!, debitBalanceId: UUID!, amount: Numeric!, creditBalanceId: UUID): Transaction!
	withdrawFiat(idempotencyKey: String!, userId: UUID!, creditBalanceId: UUID!, amount: Numeric!, debitBalanceId: UUID): Transaction!
	devClearFunds(userId: UUID!, coinInternalId: String!, amount: Numeric!): Balance!
	isCronValid(schedule: String!): Boolean!
	getNextDateFromCron(schedule: String!, date: DateTime!): DateTime!
	scheduleRecurringFiatDeposit(idempotencyKey: String!, userId: UUID!, debitBalanceId: UUID!, amount: Numeric!, startDate: DateTime!, schedule: String!, repetitions: Int, creditBalanceId: UUID): TransactonsScheduleAndTransactions!
	executeRecurringFiatDeposit(idempotencyKey: String!, userId: UUID!, transactionsScheduleId: UUID!): TransactonsScheduleAndTransactions!
	screenCryptoAddress(address: String!): PublicV1SanctionsScreeningPost201ResponseInner!
	subscribeToPlan(idempotencyKey: String!, userId: UUID!, debitBalanceId: UUID!, subscriptionId: UUID!): SubscriptionsTransaction!
	appleVerifyReceipt(receiptData: String!, userId: UUID!): Payment!
	createPlaidPublicToken(userId: UUID!, redirectUri: String, plaidMemberId: UUID): CreatePlaidPublicTokenResponse!
	linkBankInstitutionViaPlaid(userId: UUID!, plaidInstitutionId: String!, plaidPublicToken: String!): LinkBankInstitutionViaPlaidResponse!
	syncBankInstitutionViaPlaid(userId: UUID!, usersProvidersId: UUID!): SyncBankInstitutionViaPlaidResponse!
	removePlaidBankInstitution(userId: UUID!, usersProvidersId: UUID!): String!
	chargeMonthlyAumFeeAll(idempotencyKey: String!): ChargeMonthlyAumFeeAllResult!
	chargeMonthlyAumFeeForUser(userId: UUID!, idempotencyKey: String!): AumFee!
	createAlias(alias: AliasInput!): Alias!
	updateAlias(alias: AliasInput!): Alias!
	deleteAlias(uuid: UUID!, userId: UUID): Alias!
	createAsset(asset: AssetInput!): Asset!
	updateAsset(asset: AssetInput!): Asset!
	deleteAsset(uuid: UUID!, userId: UUID): Asset!
	createBalancesLabel(balancesLabel: BalancesLabelInput!): BalancesLabel!
	updateBalancesLabel(balancesLabel: BalancesLabelInput!): BalancesLabel!
	deleteBalancesLabel(uuid: UUID!, userId: UUID): BalancesLabel!
	createCoin(coin: CoinInput!): Coin!
	updateCoin(coin: CoinInput!): Coin!
	deleteCoin(uuid: UUID!, userId: UUID): Coin!
	createCoinPair(coinPair: CoinPairInput!): CoinPair!
	updateCoinPair(coinPair: CoinPairInput!): CoinPair!
	deleteCoinPair(uuid: UUID!, userId: UUID): CoinPair!
	createColor(color: ColorInput!): Color!
	updateColor(color: ColorInput!): Color!
	deleteColor(uuid: UUID!, userId: UUID): Color!
	createContract(contract: ContractInput!): Contract!
	updateContract(contract: ContractInput!): Contract!
	deleteContract(uuid: UUID!, userId: UUID): Contract!
	createFeature(feature: FeatureInput!): Feature!
	updateFeature(feature: FeatureInput!): Feature!
	deleteFeature(uuid: UUID!, userId: UUID): Feature!
	createFxRate(fxRate: FxRateInput!): FxRate!
	updateFxRate(fxRate: FxRateInput!): FxRate!
	deleteFxRate(uuid: UUID!, userId: UUID): FxRate!
	createLabel(label: LabelInput!): Label!
	updateLabel(label: LabelInput!): Label!
	deleteLabel(uuid: UUID!, userId: UUID): Label!
	createLink(link: LinkInput!): Link!
	updateLink(link: LinkInput!): Link!
	deleteLink(uuid: UUID!, userId: UUID): Link!
	createMarketCandle(marketCandle: MarketCandleInput!): MarketCandle!
	updateMarketCandle(marketCandle: MarketCandleInput!): MarketCandle!
	deleteMarketCandle(uuid: UUID!, userId: UUID): MarketCandle!
	createMarketMetric(marketMetric: MarketMetricInput!): MarketMetric!
	updateMarketMetric(marketMetric: MarketMetricInput!): MarketMetric!
	deleteMarketMetric(uuid: UUID!, userId: UUID): MarketMetric!
	createMarketTopExchange(marketTopExchange: MarketTopExchangeInput!): MarketTopExchange!
	updateMarketTopExchange(marketTopExchange: MarketTopExchangeInput!): MarketTopExchange!
	deleteMarketTopExchange(uuid: UUID!, userId: UUID): MarketTopExchange!
	createNetwork(network: NetworkInput!): Network!
	updateNetwork(network: NetworkInput!): Network!
	deleteNetwork(uuid: UUID!, userId: UUID): Network!
	createNotification(notification: NotificationInput!): Notification!
	updateNotification(notification: NotificationInput!): Notification!
	deleteNotification(uuid: UUID!, userId: UUID): Notification!
	createPayment(payment: PaymentInput!): Payment!
	updatePayment(payment: PaymentInput!): Payment!
	deletePayment(uuid: UUID!, userId: UUID): Payment!
	createPortfoliosCoin(portfoliosCoin: PortfoliosCoinInput!): PortfoliosCoin!
	updatePortfoliosCoin(portfoliosCoin: PortfoliosCoinInput!): PortfoliosCoin!
	deletePortfoliosCoin(uuid: UUID!, userId: UUID): PortfoliosCoin!
	createProvider(provider: ProviderInput!): Provider!
	updateProvider(provider: ProviderInput!): Provider!
	deleteProvider(uuid: UUID!, userId: UUID): Provider!
	createProvidersAlias(providersAlias: ProvidersAliasInput!): ProvidersAlias!
	updateProvidersAlias(providersAlias: ProvidersAliasInput!): ProvidersAlias!
	deleteProvidersAlias(uuid: UUID!, userId: UUID): ProvidersAlias!
	createReferral(referral: ReferralInput!): Referral!
	updateReferral(referral: ReferralInput!): Referral!
	deleteReferral(uuid: UUID!, userId: UUID): Referral!
	createStackDefaultsConfig(stackDefaultsConfig: StackDefaultsConfigInput!): StackDefaultsConfig!
	updateStackDefaultsConfig(stackDefaultsConfig: StackDefaultsConfigInput!): StackDefaultsConfig!
	deleteStackDefaultsConfig(uuid: UUID!, userId: UUID): StackDefaultsConfig!
	createStackDefaultsCoinsConfig(stackDefaultsCoinsConfig: StackDefaultsCoinsConfigInput!): StackDefaultsCoinsConfig!
	updateStackDefaultsCoinsConfig(stackDefaultsCoinsConfig: StackDefaultsCoinsConfigInput!): StackDefaultsCoinsConfig!
	deleteStackDefaultsCoinsConfig(uuid: UUID!, userId: UUID): StackDefaultsCoinsConfig!
	createSubscriptionPlan(subscriptionPlan: SubscriptionPlanInput!): SubscriptionPlan!
	updateSubscriptionPlan(subscriptionPlan: SubscriptionPlanInput!): SubscriptionPlan!
	deleteSubscriptionPlan(uuid: UUID!, userId: UUID): SubscriptionPlan!
	createSubscriptionsTransaction(subscriptionsTransaction: SubscriptionsTransactionInput!): SubscriptionsTransaction!
	updateSubscriptionsTransaction(subscriptionsTransaction: SubscriptionsTransactionInput!): SubscriptionsTransaction!
	deleteSubscriptionsTransaction(uuid: UUID!, userId: UUID): SubscriptionsTransaction!
	createSuitabilityAnswer(suitabilityAnswer: SuitabilityAnswerInput!): SuitabilityAnswer!
	updateSuitabilityAnswer(suitabilityAnswer: SuitabilityAnswerInput!): SuitabilityAnswer!
	deleteSuitabilityAnswer(uuid: UUID!, userId: UUID): SuitabilityAnswer!
	createSuitabilityQuestion(suitabilityQuestion: SuitabilityQuestionInput!): SuitabilityQuestion!
	updateSuitabilityQuestion(suitabilityQuestion: SuitabilityQuestionInput!): SuitabilityQuestion!
	deleteSuitabilityQuestion(uuid: UUID!, userId: UUID): SuitabilityQuestion!
	createUpcomingFeature(upcomingFeature: UpcomingFeatureInput!): UpcomingFeature!
	updateUpcomingFeature(upcomingFeature: UpcomingFeatureInput!): UpcomingFeature!
	deleteUpcomingFeature(uuid: UUID!, userId: UUID): UpcomingFeature!
	createUserAgent(userAgent: UserAgentInput!): UserAgent!
	updateUserAgent(userAgent: UserAgentInput!): UserAgent!
	deleteUserAgent(uuid: UUID!, userId: UUID): UserAgent!
	createUsersFeature(usersFeature: UsersFeatureInput!): UsersFeature!
	updateUsersFeature(usersFeature: UsersFeatureInput!): UsersFeature!
	deleteUsersFeature(uuid: UUID!, userId: UUID): UsersFeature!
	createUsersNotification(usersNotification: UsersNotificationInput!): UsersNotification!
	updateUsersNotification(usersNotification: UsersNotificationInput!): UsersNotification!
	deleteUsersNotification(uuid: UUID!, userId: UUID): UsersNotification!
	createUtmCode(utmCode: UtmCodeInput!): UtmCode!
	updateUtmCode(utmCode: UtmCodeInput!): UtmCode!
	deleteUtmCode(uuid: UUID!, userId: UUID): UtmCode!
	createWallet(wallet: WalletInput!): Wallet!
	updateWallet(wallet: WalletInput!): Wallet!
	deleteWallet(uuid: UUID!, userId: UUID): Wallet!
	createUpcomingFeatureSignup(upcomingFeatureSignup: UpcomingFeatureSignupInput!): UpcomingFeatureSignup!
	updateUpcomingFeatureSignup(upcomingFeatureSignup: UpcomingFeatureSignupInput!): UpcomingFeatureSignup!
	deleteUpcomingFeatureSignup(uuid: UUID!, userId: UUID): UpcomingFeatureSignup!
	createApiKey(apiKey: ApiKeyNodeInput!): ApiKeyNode!
	updateApiKey(apiKey: ApiKeyNodeInput!): ApiKeyNode!
	deleteApiKey(uuid: UUID!, userId: UUID!): Boolean!
	createBalance(balance: BalanceInput!): Balance!
	secureCreateBalance(userId: UUID!, coinId: UUID!, stackId: UUID!, providerId: UUID, usersProvidersId: UUID, addressName: String, address: String, addressTag: String, status: String, balance: Numeric, contractId: UUID, networkId: UUID, isHidden: Boolean, isFundingSource: Boolean, isPrimary: Boolean, isExternal: Boolean): Balance!
	updateBalance(balance: BalanceInput!): Balance!
	secureUpdateBalance(userId: UUID!, balanceId: UUID!, providerId: UUID, usersProvidersId: UUID, addressName: String, address: String, addressTag: String, status: String, balance: Numeric, isHidden: Boolean, isFundingSource: Boolean, isPrimary: Boolean, isExternal: Boolean): Balance!
	deleteBalance(uuid: UUID!, userId: UUID!): Balance!
	secureDeleteBalance(userId: UUID!, balanceId: UUID!): Balance!
	restoreBalance(uuid: UUID!, userId: UUID!): Balance!
	secureRestoreBalance(userId: UUID!, balanceId: UUID!): Balance!
	createPortfolio(portfolio: PortfolioInput!): Portfolio!
	updatePortfolio(portfolio: PortfolioInput!): Portfolio!
	deletePortfolio(uuid: UUID!, userId: UUID!): Portfolio!
	createStackAllocation(stackAllocation: StackAllocationInput!): StackAllocation!
	updateStackAllocation(stackAllocation: StackAllocationInput!): StackAllocation!
	deleteStackAllocation(uuid: UUID!, userId: UUID!): StackAllocation!
	createStack(stack: StackInput!): Stack!
	updateStack(stack: StackInput!): Stack!
	deleteStack(uuid: UUID!, userId: UUID!): Stack!
	createUsersProvider(usersProvider: UsersProviderInput!): UsersProvider!
	updateUsersProvider(usersProvider: UsersProviderInput!): UsersProvider!
	deleteUsersProvider(uuid: UUID!, userId: UUID!): UsersProvider!
	createUser(user: UserInput!): User!
	updateUser(user: UserInput!): User!
	deleteUser(uuid: UUID!): User!
	migrateUserToCognito(email: String!, password: String!, otpCode: String): User!
}

"""
A user's MX connected bank account
"""
type MxAccount {
	"""
	The unique identifier for the MX account in the Hedgehog database
	"""
	uuid: UUID!
	"""
	The unique identifier of the MX account in the MX database
	"""
	accountGuid: String!
	"""
	The unique identifier of the user associated with the MX account in the MX database
	"""
	userGuid: String!
	"""
	The unique identifier of the user's membership in an institution in the MX database
	"""
	memberGuid: String!
	"""
	The unique identifier of the user_provider associated with MX account in the Hedgehog database
	"""
	usersProvidersId: UUID!
	"""
	The unique identifier of the user associated with the MX account in the Hedgehog database
	"""
	userId: UUID!
	"""
	The type of the MX account, eg. 'checking' or 'savings'
	"""
	type: String
	"""
	Whether the identity of the user owning the account has been verified against the user's persona_inquiry
	"""
	isIdentityChecked: Boolean
	"""
	Whether the identity of the user owning the account matches the user's persona_inquiry
	"""
	doesIdentityMatchKyc: Boolean
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	usersProvider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UsersProvider!]!
}

type MxAccountPayload {
	action: String!
	payload: MxAccount
	error: String
}

type MxMember {
	"""
	The unique identifier for the MX member in the Hedgehog database
	"""
	uuid: UUID!
	"""
	The unique identifier of the MX member in the MX database
	"""
	memberGuid: String!
	"""
	The unique identifier of the user in the MX database
	"""
	userGuid: String!
	"""
	The date and time the account balances were attempted to aggregated
	"""
	aggregatedAt: DateTime
	"""
	The date and time the account balances were successfully aggregated
	"""
	successfullyAggregatedAt: DateTime
	"""
	The status of the connection between the MX member institution and the user
	"""
	connectionStatus: String
	"""
	Whether the MX member institution has identity validation available
	"""
	isIdentityAvailable: Boolean
	"""
	The unique identifier of the user_provider in the Hedgehog database
	"""
	usersProvidersId: UUID!
	"""
	The unique identifier of the user in the Hedgehog database
	"""
	userId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	usersProvider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UsersProvider!]!
}

type MxMemberPayload {
	action: String!
	payload: MxMember
	error: String
}

"""
A user's MX identity
"""
type MxUser {
	"""
	The unique identifier for the MX user in the Hedgehog database
	"""
	uuid: UUID!
	"""
	The unique identifier of the MX user in the MX database
	"""
	userGuid: String!
	"""
	The unique identifier of the user in the Hedgehog database
	"""
	userId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was deleted in the database
	"""
	deletedAt: DateTime
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

type MxUserPayload {
	action: String!
	payload: MxUser
	error: String
}

"""
ISO 8601 calendar date without timezone.
Format: %Y-%m-%d

# Examples

* `1994-11-13`
* `2000-02-24`
"""
scalar NaiveDate

"""
A transaction network or cryptocurrency protocol where money can be stored and transmitted
"""
type Network {
	"""
	The unique identifier for the network
	"""
	uuid: UUID!
	"""
	The human-readable name of the network
	"""
	networkName: String!
	"""
	The identifier used at Gemini Exchange for the network, if applicable
	"""
	geminiName: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	contracts(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Contract!]!
}

"""
Builder for [`Network`](struct.Network.html).
"""
input NetworkInput {
	"""
	The unique identifier for the network
	"""
	uuid: UUID
	"""
	The human-readable name of the network
	"""
	networkName: String
	"""
	The identifier used at Gemini Exchange for the network, if applicable
	"""
	geminiName: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type NetworkPayload {
	action: String!
	payload: Network
	error: String
}

"""
System-wide notifications regarding coins or providers
"""
type Notification {
	"""
	The unique identifier for the notification
	"""
	uuid: UUID!
	"""
	The title of the notification
	"""
	title: String
	"""
	The content blocks inside the notification
	"""
	contents: JSON
	"""
	The subtitles at the top of the notification
	"""
	subtitleTop: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
}

"""
Builder for [`Notification`](struct.Notification.html).
"""
input NotificationInput {
	"""
	The unique identifier for the notification
	"""
	uuid: UUID
	"""
	The title of the notification
	"""
	title: String
	"""
	The content blocks inside the notification
	"""
	contents: JSON
	"""
	The subtitles at the top of the notification
	"""
	subtitleTop: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type NotificationPayload {
	action: String!
	payload: Notification
	error: String
}

"""
A Numeric type represents a string, a precision, and a scale, and helps to avoid floating point errors in financially sensitive applications. The Rust server will convert Postgres native numeric types to BigDecimal and then convert a BigDecimal to a String for consumption by the front-end.
"""
scalar Numeric

"""
The exchange of one currency for another on any provider
"""
type Order {
	"""
	The unique identifier for the order
	"""
	uuid: UUID!
	"""
	The unique identifier of the user associated with the order
	"""
	userId: UUID!
	"""
	The unique identifier of the base coin associated with the order
	"""
	baseCoinId: UUID!
	"""
	The unique identifier of the quote coin associated with the order
	"""
	quoteCoinId: UUID!
	"""
	The unique identifier of the users provider associated with the order
	"""
	usersProvidersId: UUID!
	"""
	The unique identifier of the api key associated with the order
	"""
	apiKeyId: UUID
	"""
	The unique identifier of the network associated with the order
	"""
	networkId: UUID
	"""
	The unique identifier of the contract associated with the order
	"""
	contractId: UUID
	"""
	The data source reporting the order
	"""
	source: String!
	"""
	The timestamp of the order
	"""
	sourceTs: DateTime!
	"""
	The unique identifier of the order on the exchange
	"""
	externalId: String
	"""
	The unique identifier of the order on the exchange, as determined by the client
	"""
	clientExternalId: String
	"""
	The status of the order, eg pending, failed, completed
	"""
	orderStatus: String!
	"""
	The type of the order, eg limit, market, stop
	"""
	orderType: String!
	"""
	Whether the order is short or long
	"""
	isShort: Boolean!
	"""
	The limit price of the order, if applicable
	"""
	orderLimit: Numeric
	"""
	The stop price of the order, if applicable
	"""
	orderStop: Numeric
	"""
	The expiration timestamp of the order, if applicable
	"""
	expirationTs: DateTime
	"""
	The price of the order
	"""
	price: Numeric!
	"""
	The amount of the order
	"""
	amount: Numeric!
	"""
	The allowable drift in market price as the order book is consumed
	"""
	slippage: Numeric
	"""
	The nonce of the order, sent for security purposes
	"""
	nonce: Int
	"""
	The unique identifier of the credit balance associated with the order
	"""
	creditBalanceId: UUID
	"""
	The unique identifier of the debit balance associated with the order
	"""
	debitBalanceId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	"""
	Whether the order is hidden from the client
	"""
	isHidden: Boolean
	"""
	The ID of the user that initiated the order
	"""
	requesterId: UUID
	"""
	The unique identifier of the stack rebalance schedule associated with the order
	"""
	stackRebalanceScheduleId: UUID
	base(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	quote(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	contract(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Contract!]!
	network(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_asc"]): [Network!]!
	orderSchedules(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_ts_desc"]): [OrderSchedule!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
	usersProvider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UsersProvider!]!
}

"""
The executed legs of an order or partially executed order that aggregate to the average price
"""
type OrderFill {
	"""
	The unique identifier for the order fill
	"""
	uuid: UUID!
	"""
	The unique identifier of the user associated with the order fill
	"""
	userId: UUID!
	"""
	The unique identifier of the debit transfer associated with the order fill
	"""
	debitTransferId: UUID!
	"""
	The unique identifier of the credit transfer associated with the order fill
	"""
	creditTransferId: UUID!
	"""
	The unique identifier of the order associated with the order fill
	"""
	orderId: UUID!
	"""
	The source reporting the order fill
	"""
	source: String!
	"""
	The timestamp of the order fill
	"""
	sourceTs: DateTime!
	"""
	The unique identifier of the order fill in the source database
	"""
	externalOrderId: String
	"""
	The unique identifier of the user in the source database
	"""
	clientExternalId: String
	"""
	The price of the order fill
	"""
	price: Numeric!
	"""
	The amount of the order fill
	"""
	amount: Numeric!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	order(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [Order!]!
	debit(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Transfer!]!
	credit(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Transfer!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

type OrderFillPayload {
	action: String!
	payload: OrderFill
	error: String
}

"""
Connects order fills and fees
"""
type OrderFillsFee {
	"""
	The unique identifier for the order fill fee
	"""
	uuid: UUID!
	"""
	The unique identifier of the user associated with the order fill fee
	"""
	userId: UUID!
	"""
	The unique identifier of the order fill associated with the order fill fee
	"""
	orderFillId: UUID!
	"""
	The unique identifier of the fee associated with the order fill fee
	"""
	feeId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	fee(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Fee!]!
}

type OrderFillsFeePayload {
	action: String!
	payload: OrderFillsFee
	error: String
}

type OrderPayload {
	action: String!
	payload: Order
	error: String
}

"""
Sets a date and interval for executing a proposed order
"""
type OrderSchedule {
	"""
	The unique identifier for the order schedule
	"""
	uuid: UUID!
	"""
	The unique identifier of the order associated with the order schedule
	"""
	orderId: UUID!
	"""
	The unique identifier of the user associated with the order schedule
	"""
	userId: UUID!
	"""
	The date and time the order is scheduled to execute
	"""
	orderTs: DateTime!
	"""
	The cron expression for the schedule on which to plan the next order
	"""
	schedule: String!
	"""
	Whether the order schedule is active or not
	"""
	isActive: Boolean!
	"""
	The number of remaining times the order should be executed
	"""
	repetitions: Int
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	order(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [Order!]!
}

type OrderScheduleAndOrders {
	"""
	The upserted order schedule
	"""
	orderSchedule: OrderSchedule!
	"""
	The executed order
	"""
	executedOrder: Order
	"""
	The next scheduled order for the related schedule
	"""
	scheduledOrder: Order
}

type OrderSchedulePayload {
	action: String!
	payload: OrderSchedule
	error: String
}

type Pagination {
	currentPage: Int!
	perPage: Int!
	totalEntries: Int!
	totalPages: Int!
}

"""
A panel contains content for a specific coin
"""
type Panel {
	"""
	The unique identifier for the panel
	"""
	uuid: UUID!
	"""
	The title of the panel
	"""
	title: String!
	"""
	The order of the panel for render purposes
	"""
	order: Int!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier of the coin associated with the panel
	"""
	coinId: UUID
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	contents(where: Where, limit: Int! = 20, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Content!]!
	cryptoGroup(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [CryptoGroup!]!
}

type PanelPayload {
	action: String!
	payload: Panel
	error: String
}

"""
A normalized table to record subscription payments from third party payment providers
such as Apple Pay, Google Pay, Plaid, or Stripe
"""
type Payment {
	"""
	The unique identifier for this payment
	"""
	uuid: UUID!
	"""
	The user associated with the payment
	"""
	userId: UUID!
	"""
	The source of the payment receipt, eg apple, google, etc
	"""
	source: String!
	"""
	The external transaction id from the payment provider
	"""
	externalTransactionId: String
	"""
	The external customer id from the payment provider
	"""
	externalCustomerId: String
	"""
	The external subscription id from the payment provider
	"""
	externalSubscriptionId: String
	"""
	The timestamp of the most recent payment
	"""
	paymentTs: DateTime
	"""
	The timestamp of the latest subscription expiry
	"""
	expiryTs: DateTime
	"""
	The status of the payment, ie valid or invalid
	"""
	status: String
	"""
	The data required by the client application to verify the receipt locally
	"""
	localVerificationData: String
	"""
	The data required by the server to verify the receipt
	"""
	serverVerificationData: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
Builder for [`Payment`](struct.Payment.html).
"""
input PaymentInput {
	"""
	The unique identifier for this payment
	"""
	uuid: UUID
	"""
	The user associated with the payment
	"""
	userId: UUID
	"""
	The source of the payment receipt, eg apple, google, etc
	"""
	source: String
	"""
	The external transaction id from the payment provider
	"""
	externalTransactionId: String
	"""
	The external customer id from the payment provider
	"""
	externalCustomerId: String
	"""
	The external subscription id from the payment provider
	"""
	externalSubscriptionId: String
	"""
	The timestamp of the most recent payment
	"""
	paymentTs: DateTime
	"""
	The timestamp of the latest subscription expiry
	"""
	expiryTs: DateTime
	"""
	The status of the payment, ie valid or invalid
	"""
	status: String
	"""
	The data required by the client application to verify the receipt locally
	"""
	localVerificationData: String
	"""
	The data required by the server to verify the receipt
	"""
	serverVerificationData: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
}

type PaymentMethodBank {
	bank: String!
	bankId: String!
}

type PaymentMethods {
	balances: [GetAvailableBalancesResponseBalance!]!
	banks: [PaymentMethodBank!]!
}

type PaymentPayload {
	action: String!
	payload: Payment
	error: String
}

"""
Describes the paywall status of a user and their ability to consume adviser services
"""
type Paywall {
	hasAgreedToServices: Boolean!
	hasPassedKyc: Boolean!
	hasTrading: Boolean!
	hasPaid: Boolean!
	hasBeenDisqualified: Boolean!
}

type PersonaInquiry {
	"""
	The unique identifier for the persona inquiry in the Hedgehog database
	"""
	uuid: UUID!
	"""
	The unique identifier for the persona inquiry at Persona
	"""
	personaInquiryId: String!
	"""
	The status of the persona inquiry, ie 'approved', 'rejected', 'pending', 'marked-for-review', 'failed'
	"""
	inquiryStatus: String!
	"""
	The unique identifier for the user in the Hedgehog database
	"""
	userId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was deleted in the database
	"""
	deletedAt: DateTime
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

type PersonaInquiryPayload {
	action: String!
	payload: PersonaInquiry
	error: String
}

"""
A model to include all relevant details to a client's connected bank or card account via Plaid
"""
type PlaidAccount {
	"""
	The unique identifier for the Plaid member in the Hedgehog database
	"""
	uuid: UUID!
	"""
	The unique identifier of the user in the Hedgehog database
	"""
	userId: UUID!
	"""
	The unique identifier of the users_provider in the Hedgehog database
	"""
	usersProvidersId: UUID!
	"""
	The unique identifier of the plaid_members in the Hedgehog database
	"""
	plaidMemberId: UUID!
	"""
	The external ID that Plaid uses to identify the account.
	"""
	plaidAccountId: String!
	"""
	The unique identifier of the gemini_account in the Hedgehog database
	"""
	geminiUserAccountId: UUID
	"""
	External ID given by Gemini that represents the bank account for money transfers.
	"""
	geminiBankAccountId: String
	"""
	The unique identifier of the api_key in the Hedgehog database
	"""
	processorTokenApiKeyId: UUID
	"""
	Editable, human-readable string used to identify the account.
	"""
	label: String
	"""
	Name of the account provided directly by Plaid.
	"""
	name: String!
	"""
	The last X digits of the account number, where X varies depending on the institution. This information is provided by Plaid as the 'mask' field.
	"""
	lastDigits: String
	"""
	The date and time the account balances were successfully aggregated
	"""
	lastSyncedAt: DateTime
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	usersProvider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UsersProvider!]!
}

"""
Contains details necessary to connect a Plaid account to the bank or card processing institution in the Plaid database and the provider in the Hedgehog database
"""
type PlaidMember {
	"""
	The unique identifier for the MX member in the Hedgehog database
	"""
	uuid: UUID!
	"""
	The unique identifier of the user in the Hedgehog database
	"""
	userId: UUID!
	"""
	The unique identifier of the users_provider in the Hedgehog database
	"""
	usersProvidersId: UUID!
	"""
	The unique identifier of the institution connection provided directly by Plaid. This is the item ID.
	"""
	externalConnectionId: String!
	"""
	The unique identifier of the api_key in the Hedgehog database
	"""
	accessTokenApiKeyId: UUID!
	"""
	The status of the connection between the Plaid member institution and the user which can have one of two values: 'active' or 'error'.
	"""
	connectionStatus: String
	"""
	A string provided by Plaid that can be used in programming, but is not meant for display to a human. It is set to NULL by default and will only be populated when the connection_status is 'error'
	"""
	connectionErrorCode: String
	"""
	The date and time the account balances were successfully aggregated
	"""
	lastSyncedAt: DateTime
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	usersProvider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UsersProvider!]!
}

"""
A collection of Stacks which are themselves a collection of assets
"""
type Portfolio {
	"""
	The unique identifier for the portfolio
	"""
	uuid: UUID!
	"""
	The human-readable name of the portfolio
	"""
	name: String!
	"""
	A description of the portfolio
	"""
	description: String!
	"""
	The strategy used to rebalance the portfolio, eg MARKETCAP, TXCOUNT, ACTIVEADDRESSES
	"""
	strategy: String
	"""
	The upper threshold for indicating the portfolio urgently needs to be rebalanced
	"""
	upperRebalanceThreshold: Int
	"""
	The middle threshold for indicating the portfolio should be rebalanced soon
	"""
	middleRebalanceThreshold: Int
	"""
	The lower threshold for indicating the portfolio may need to be rebalanced
	"""
	lowerRebalanceThreshold: Int
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier for the user who owns the portfolio
	"""
	userId: UUID!
	"""
	The unique identifier for the user-selected color of the portfolio
	"""
	colorId: UUID
	"""
	The unique identifier for the icon of the portfolio
	"""
	iconId: String
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	"""
	Indicates whether a portfolio is custodial or not, helping to differentiate between portfolios managed internally or externally.
	"""
	isManaged: Boolean!
	colors(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [String!]!
	portfoliosCoins(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [PortfoliosCoin!]!
	portfolioMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [PortfoliosV!]!
	stacks(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_asc"]): [Stack!]!
	stacksMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [StacksV!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
This model aggregates the balances of a given asset within a portfolio,
eg, all the BTC balances in your primary portfolio which includes multiple stacks
"""
type PortfolioAssetsV {
	"""
	The unique identifier for the associated user asset
	"""
	assetId: UUID
	"""
	The unique identifier for the associated user
	"""
	userId: UUID
	"""
	The unique identifier for the associated coin
	"""
	coinId: UUID
	"""
	The unique identifier for the associated portfolio
	"""
	portfolioId: UUID
	"""
	The human-readable unique identifier for the associated coin
	"""
	coinInternalId: String
	"""
	The symbol generally used in order books for the associated coin
	"""
	coinSymbol: String
	"""
	The coin order for the associated coin
	"""
	coinOrder: Int
	"""
	Whether the asset is hearted by the user
	"""
	isHearted: Boolean
	"""
	The balance of the asset in the portfolio
	"""
	balance: Numeric
	"""
	The balance of the asset in the portfolio denominated in USD
	"""
	balanceUsd: Numeric
	"""
	The price of the asset in USD
	"""
	fxRateUsd: Numeric
	"""
	The total number of balances that make up a user's portfolio asset balance
	"""
	balanceCount: Int
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	marketCandles(where: Where, limit: Int! = 0, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [MarketCandle!]!
	marketLatestMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [MarketLatestMetrics!]!
	marketMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [MarketMetric!]!
	portfolio(where: Where, limit: Int! = 10, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Portfolio!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

type PortfolioGraphCandle {
	sourceTs: String!
	portfolioId: String!
	valueChangePercent: String!
	valueChangeUsd: String!
	valueOpenUsd: String!
	valueCloseUsd: String!
	valueLowUsd: String!
	valueHighUsd: String!
}

"""
Builder for [`PortfolioGraphRequest`](struct.PortfolioGraphRequest.html).
"""
input PortfolioGraphRequestInput {
	userId: UUID
	portfolioId: UUID
	frequency: String
	startDate: String
	endDate: String
	candlesReturned: String
}

type PortfolioGraphResponse {
	portfolioId: UUID!
	userId: UUID!
	frequency: String!
	startDate: String!
	endDate: String!
	candles: [PortfolioGraphCandle!]!
}

"""
Builder for [`Portfolio`](struct.Portfolio.html).
"""
input PortfolioInput {
	"""
	The unique identifier for the portfolio
	"""
	uuid: UUID
	"""
	The human-readable name of the portfolio
	"""
	name: String
	"""
	A description of the portfolio
	"""
	description: String
	"""
	The strategy used to rebalance the portfolio, eg MARKETCAP, TXCOUNT, ACTIVEADDRESSES
	"""
	strategy: String
	"""
	The upper threshold for indicating the portfolio urgently needs to be rebalanced
	"""
	upperRebalanceThreshold: Int
	"""
	The middle threshold for indicating the portfolio should be rebalanced soon
	"""
	middleRebalanceThreshold: Int
	"""
	The lower threshold for indicating the portfolio may need to be rebalanced
	"""
	lowerRebalanceThreshold: Int
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The unique identifier for the user who owns the portfolio
	"""
	userId: UUID
	"""
	The unique identifier for the user-selected color of the portfolio
	"""
	colorId: UUID
	"""
	The unique identifier for the icon of the portfolio
	"""
	iconId: String
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	"""
	Indicates whether a portfolio is custodial or not, helping to differentiate between portfolios managed internally or externally.
	"""
	isManaged: Boolean
}

"""
Builder for [`PortfolioMinDepositRequestCoin`](struct.PortfolioMinDepositRequestCoin.html).
"""
input PortfolioMinDepositRequestCoinInput {
	symbol: String
	targetWeight: String
}

"""
Builder for [`PortfolioMinDepositRequest`](struct.PortfolioMinDepositRequest.html).
"""
input PortfolioMinDepositRequestInput {
	coins: [PortfolioMinDepositRequestCoinInput!]!
	providerId: UUID
}

type PortfolioMinDepositResponse {
	coins: [PortfolioMinDepositResponseCoin!]!
	providerId: String
}

type PortfolioMinDepositResponseCoin {
	symbol: String!
	targetWeight: String!
	minDeposit: String
}

type PortfolioPayload {
	action: String!
	payload: Portfolio
	error: String
}

type PortfolioWeight {
	portfolioId: String!
	currentRating: String!
	currentValueUsd: String!
	stackWeights: [StackWeight!]!
}

"""
Builder for [`PortfolioWeightRequest`](struct.PortfolioWeightRequest.html).
"""
input PortfolioWeightRequestInput {
	userId: UUID
	portfolioId: UUID
}

"""
Connects a portfolio to its coins
"""
type PortfoliosCoin {
	"""
	The unique identifier for the portfolio coin
	"""
	uuid: UUID!
	"""
	The unique identifier for the portfolio the coin is associated with
	"""
	portfolioId: UUID!
	"""
	The unique identifier for the coin the portfolio is associated with
	"""
	coinId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	Whether or not the coin is hidden from the portfolio
	"""
	isHidden: Boolean!
}

"""
Builder for [`PortfoliosCoin`](struct.PortfoliosCoin.html).
"""
input PortfoliosCoinInput {
	"""
	The unique identifier for the portfolio coin
	"""
	uuid: UUID
	"""
	The unique identifier for the portfolio the coin is associated with
	"""
	portfolioId: UUID
	"""
	The unique identifier for the coin the portfolio is associated with
	"""
	coinId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	Whether or not the coin is hidden from the portfolio
	"""
	isHidden: Boolean
}

type PortfoliosCoinPayload {
	action: String!
	payload: PortfoliosCoin
	error: String
}

"""
This model aggregates the total USD value and market cap and metrics of a given user portfolio
"""
type PortfoliosV {
	"""
	References the relevant user
	"""
	userId: UUID
	"""
	References the relevant portfolio
	"""
	portfolioId: UUID
	"""
	The aggregate USD value of the portfolio
	"""
	balanceUsd: Numeric
	"""
	The aggregate USD value of the portfolio excluding the values of mx related balances
	"""
	mxExcludedBalanceUsd: Numeric
	"""
	The aggregate USD value of the portfolio inluding the values of mx related balances
	"""
	mxIncludedBalanceUsd: Numeric
	"""
	The aggregate USD value of the portfolio market cap
	"""
	marketCapUsd: Numeric
	"""
	The aggregate daily active addresses of all assets in the portfolio
	"""
	activeAddresses: Numeric
	"""
	The aggregate daily transaction count of all assets in the portfolio
	"""
	txCount: Numeric
	"""
	The total portfolio value change in the last 24 hours
	"""
	percentChange24Hours: Numeric
	"""
	The total portfolio value change in the last week
	"""
	percentChange1Week: Numeric
	"""
	The total portfolio value change in the last 30 days
	"""
	percentChange1Month: Numeric
	"""
	The total portfolio value change in the last 3 months
	"""
	percentChange3Month: Numeric
	"""
	The total portfolio value change in the last 6 months
	"""
	percentChange6Month: Numeric
	"""
	The total portfolio value change in the last 1 year
	"""
	percentChange1Year: Numeric
	"""
	The total portfolio value change in the last 2 years
	"""
	percentChange2Year: Numeric
	"""
	The total portfolio value change in the last 3 years
	"""
	percentChange3Year: Numeric
	"""
	The total fraction the portfolio value represents of all the value in the user's balances
	"""
	percentOfTotalUserBalance: Numeric
	"""
	The number of stacks that reference this portfolio
	"""
	stackCount: Int
	"""
	The number of assets that reference this portfolio
	"""
	assetCount: Int
	"""
	The number of balances that reference this portfolio
	"""
	balanceCount: Int
	"""
	The strategy associated with the portfolio
	"""
	strategy: String
	"""
	Indicates whether a portfolio is custodial or not, helping to differentiate between portfolios managed internally or externally.
	"""
	isManaged: Boolean!
	portfolio(where: Where, limit: Int! = 10, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Portfolio!]!
	portfolioAssetsV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [PortfolioAssetsV!]!
	stacksMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [StacksV!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

type Precision {
	price: Numeric
	amount: Numeric
	cost: Numeric
}

"""
Builder for [`ProfitLossEmailRequest`](struct.ProfitLossEmailRequest.html).
"""
input ProfitLossEmailRequestInput {
	userId: String
	email: String
	stacks: [StackProfitLossDetail!]
}

"""
A venue for trading, holding. or tracking currency
"""
type Provider {
	"""
	The unique identifier for the provider
	"""
	uuid: UUID!
	"""
	The human-readable name of the provider
	"""
	name: String!
	"""
	The type of provider, eg exchange, software wallet, hardware wallet, etc
	"""
	type: String!
	"""
	A URL to an image representing the provider
	"""
	image: String
	"""
	A URL to an icon representing the provider
	"""
	icon: String!
	"""
	A URL to the provider's website
	"""
	link: String!
	"""
	The ID of the provider in the CCXT library, frequently used by other firms
	"""
	ccxtId: String
	"""
	The default coin when creating a wallet connected to the provider, eg BTC for Bitstamp
	"""
	defaultCoin: String!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	A URL to a guide for using the provider on Hedgehog
	"""
	guide: String
	"""
	A JSON object of default parameters for the provider that should be passed into the CCXT library for all APIs
	"""
	defaultParams: JSON!
	"""
	A JSON object of parameters for the provider that should be passed into the CCXT library, broken out by API
	"""
	ccxtParams: JSON!
	"""
	A JSON object of notes for the provider
	"""
	notes: JSON!
	"""
	The order in which the provider should be displayed in the UI
	"""
	order: Int
	"""
	The URI for the OAuth2 authorization endpoint
	"""
	oauthAuthorizeUri: String
	"""
	The client ID for the OAuth2 authorization endpoint
	"""
	oauthClientId: String
	"""
	The URI for the OAuth2 revocation endpoint
	"""
	oauthRevokeUri: String
	"""
	The URI for the OAuth2 token endpoint
	"""
	oauthTokenUri: String
	"""
	The human-readable internal ID for the provider to be used in url parameters
	"""
	internalId: String
	"""
	Whether the provider should be hidden from the UI
	"""
	isHidden: Boolean
	"""
	The ID of the color to be used in the UI
	"""
	colorId: UUID!
	"""
	The ID of the provider in the MX database, used to identify banks and other traditional financial institutions
	"""
	mxId: String
	"""
	Whether the provider supports MX account owner identification
	"""
	isMxAccountIdentificationSupported: Boolean
	"""
	A description for the provider, used in the UI to describe the venue, software, or hardware
	"""
	description: String
	"""
	The unique identifier of the provider in the Plaid database, used to identify banks and other traditional financial institutions
	"""
	plaidExternalInstitutionId: String
	"""
	Whether the provider is an active product for customer use
	"""
	isActive: Boolean
	colors(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [String!]!
	fxRatesUsd(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [FxLatestUsdRatesV!]!
	fxRates(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [FxRatesV!]!
	topExchanges(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["volume_24h_usd_desc"]): [MarketTopExchangesV!]!
	providersAliases(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [ProvidersAlias!]!
	wallets(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Wallet!]!
	walletsV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["coin_internal_id_desc"]): [WalletsV!]!
}

"""
Builder for [`Provider`](struct.Provider.html).
"""
input ProviderInput {
	"""
	The unique identifier for the provider
	"""
	uuid: UUID
	"""
	The human-readable name of the provider
	"""
	name: String
	"""
	The type of provider, eg exchange, software wallet, hardware wallet, etc
	"""
	type: String
	"""
	A URL to an image representing the provider
	"""
	image: String
	"""
	A URL to an icon representing the provider
	"""
	icon: String
	"""
	A URL to the provider's website
	"""
	link: String
	"""
	The ID of the provider in the CCXT library, frequently used by other firms
	"""
	ccxtId: String
	"""
	The default coin when creating a wallet connected to the provider, eg BTC for Bitstamp
	"""
	defaultCoin: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	A URL to a guide for using the provider on Hedgehog
	"""
	guide: String
	"""
	A JSON object of default parameters for the provider that should be passed into the CCXT library for all APIs
	"""
	defaultParams: JSON
	"""
	A JSON object of parameters for the provider that should be passed into the CCXT library, broken out by API
	"""
	ccxtParams: JSON
	"""
	A JSON object of notes for the provider
	"""
	notes: JSON
	"""
	The order in which the provider should be displayed in the UI
	"""
	order: Int
	"""
	The URI for the OAuth2 authorization endpoint
	"""
	oauthAuthorizeUri: String
	"""
	The client ID for the OAuth2 authorization endpoint
	"""
	oauthClientId: String
	"""
	The URI for the OAuth2 revocation endpoint
	"""
	oauthRevokeUri: String
	"""
	The URI for the OAuth2 token endpoint
	"""
	oauthTokenUri: String
	"""
	The human-readable internal ID for the provider to be used in url parameters
	"""
	internalId: String
	"""
	Whether the provider should be hidden from the UI
	"""
	isHidden: Boolean
	"""
	The ID of the color to be used in the UI
	"""
	colorId: UUID
	"""
	The ID of the provider in the MX database, used to identify banks and other traditional financial institutions
	"""
	mxId: String
	"""
	Whether the provider supports MX account owner identification
	"""
	isMxAccountIdentificationSupported: Boolean
	"""
	A description for the provider, used in the UI to describe the venue, software, or hardware
	"""
	description: String
	"""
	The unique identifier of the provider in the Plaid database, used to identify banks and other traditional financial institutions
	"""
	plaidExternalInstitutionId: String
	"""
	Whether the provider is an active product for customer use
	"""
	isActive: Boolean
}

type ProviderPayload {
	action: String!
	payload: Provider
	error: String
}

"""
Connects a provider to its aliases
"""
type ProvidersAlias {
	"""
	The unique identifier for the provider alias
	"""
	uuid: UUID!
	"""
	The unique identifier for the provider the alias is associated with
	"""
	providerId: UUID
	"""
	The unique identifier for the alias the provider is associated with
	"""
	aliasId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	alias(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Alias!]!
	provider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [Provider!]!
}

"""
Builder for [`ProvidersAlias`](struct.ProvidersAlias.html).
"""
input ProvidersAliasInput {
	"""
	The unique identifier for the provider alias
	"""
	uuid: UUID
	"""
	The unique identifier for the provider the alias is associated with
	"""
	providerId: UUID
	"""
	The unique identifier for the alias the provider is associated with
	"""
	aliasId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type ProvidersAliasPayload {
	action: String!
	payload: ProvidersAlias
	error: String
}

type PublicV1SanctionsScreeningPost201ResponseInner {
	"""
	The the initial address submitted to the API. This is provided to help match the address in the response to the address in the original request.
	"""
	address: String!
	isSanctioned: Boolean!
}

"""
The customer's account at Qolo, used for sending and receiving fiat currency
"""
type QoloAccount {
	"""
	The unique identifier for the qolo account in the Hedgehog database
	"""
	uuid: UUID!
	"""
	The unique identifier for the qolo account at Qolo
	"""
	accountGuid: String!
	"""
	The unique identifier for the qolo wallet at Qolo
	"""
	walletGuid: String!
	"""
	The unique identifier for the user at Qolo
	"""
	personGuid: String!
	"""
	The unique identifier for the user in the Hedgehog database
	"""
	userId: UUID!
	"""
	The unique identifier for the user's provider in the Hedgehog database
	"""
	usersProvidersId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was deleted in the database
	"""
	deletedAt: DateTime
}

type QoloAccountPayload {
	action: String!
	payload: QoloAccount
	error: String
}

"""
The customer's external bank account that can make deposits to their Qolo account
"""
type QoloOutsideInstrument {
	"""
	The unique identifier for the qolo outside instrument in the Hedgehog database
	"""
	uuid: UUID!
	"""
	The unique identifier for the qolo outside instrument at Qolo
	"""
	outsideInstrumentGuid: String!
	"""
	The unique identifier for the user at Qolo
	"""
	personGuid: String!
	"""
	The unique identifier for the MX account in the Hedgehog database
	"""
	mxAccountId: UUID!
	"""
	The unique identifier for the user's provider in the Hedgehog database
	"""
	usersProvidersId: UUID!
	"""
	The type of instrument, e.g. bank account, credit card, etc.
	"""
	instrumentType: String
	"""
	The unique identifier for the user in the Hedgehog database
	"""
	userId: UUID!
	"""
	The date the row was created in the Hedgehog database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the Hedgehog database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the Hedgehog database
	"""
	deletedAt: DateTime
	usersProvider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UsersProvider!]!
}

type QoloOutsideInstrumentPayload {
	action: String!
	payload: QoloOutsideInstrument
	error: String
}

"""
The user's identity on the Qolo platform
"""
type QoloPerson {
	"""
	The unique identifier for the qolo person in the Hedgehog database
	"""
	uuid: UUID!
	"""
	The unique identifier for the qolo person at Qolo
	"""
	personGuid: String!
	"""
	The unique identifier for the user in the Hedgehog database
	"""
	userId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

type QoloPersonPayload {
	action: String!
	payload: QoloPerson
	error: String
}

"""
The user's account and OutsideInstrument container at Qolo
"""
type QoloWallet {
	"""
	The unique identifier for the qolo wallet in the Hedgehog database
	"""
	uuid: UUID!
	"""
	The unique identifier for the qolo wallet at Qolo
	"""
	walletGuid: String!
	"""
	The unique identifier for the user at Qolo
	"""
	personGuid: String!
	"""
	The unique identifier for the user in the Hedgehog database
	"""
	userId: UUID!
	"""
	The unique identifier for the user's provider in the Hedgehog database
	"""
	usersProvidersId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
}

type QoloWalletPayload {
	action: String!
	payload: QoloWallet
	error: String
}

type Query {
	getUserCognitoMigrationStatus(email: String!): Boolean!
	getHopscotchQuote(userId: String!, graphId: String!, userBase: String!, userSize: String!, pathsScan: String, pathsCache: String): QuotesResponse!
	validatePaywall(userId: UUID!): Paywall!
	validateSubscription(userId: UUID!, paymentId: UUID): Boolean!
	"""
	Returns a list of Alias.
	"""
	aliases(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Alias!]!
	"""
	Returns a list of Assets.
	"""
	assets(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at"]): [Asset!]!
	"""
	Returns a list of AssetsVs.
	"""
	assetsV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [AssetsV!]!
	"""
	Returns a list of AumFees.
	"""
	aumFees(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [AumFee!]!
	"""
	Returns a list of BalancesLabels.
	"""
	balancesLabels(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [BalancesLabel!]!
	"""
	Returns a list of Coins.
	"""
	coins(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	"""
	Returns a list of CoinsContracts.
	"""
	coinsContracts(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [CoinsContract!]!
	"""
	Returns a list of CoinsContractsVs.
	"""
	coinsContractsV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["internal_id"]): [CoinsContractsV!]!
	"""
	Returns a list of CoinsCryptoGroups.
	"""
	coinsCryptoGroups(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [CoinsCryptoGroup!]!
	"""
	Returns a list of CoinOfferings.
	"""
	coinOfferings(where: Where, limit: Int! = 0, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [CoinOffering!]!
	"""
	Returns a list of CoinPair.
	"""
	coinPair(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [CoinPair!]!
	"""
	Returns a list of CoinResearches.
	"""
	coinResearch(where: Where, limit: Int! = 0, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [CoinResearch!]!
	"""
	Returns a list of Colors.
	"""
	colors(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Color!]!
	"""
	Returns a list of Contents.
	"""
	contents(where: Where, limit: Int! = 20, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Content!]!
	"""
	Returns a list of Contracts.
	"""
	contracts(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Contract!]!
	"""
	Returns a list of Countries.
	"""
	countries(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Country!]!
	"""
	Returns a list of CryptoEntities.
	"""
	cryptoEntities(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [CryptoEntity!]!
	"""
	Returns a list of CryptoGroups.
	"""
	cryptoGroups(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [CryptoGroup!]!
	"""
	Returns a list of CryptoMembers.
	"""
	cryptoMembers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [CryptoMember!]!
	"""
	Returns a list of Elements.
	"""
	elements(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Element!]!
	"""
	Returns a list of Features.
	"""
	features(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Feature!]!
	"""
	Returns a list of FxLatestUsdRatesVs.
	"""
	fxLatestUsdRatesV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [FxLatestUsdRatesV!]!
	"""
	Returns a list of FxRates.
	"""
	fxRates(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [FxRate!]!
	"""
	Returns a list of FxRatesVs.
	"""
	fxRatesV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [FxRatesV!]!
	"""
	Returns a list of GeminiAccounts.
	"""
	geminiAccounts(where: Where, limit: Int! = 10, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [GeminiAccount!]!
	"""
	Returns a list of Labels.
	"""
	labels(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Label!]!
	"""
	Returns a list of Links.
	"""
	links(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_asc"]): [Link!]!
	"""
	Returns a list of Lots.
	"""
	lots(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Lot!]!
	"""
	Returns a list of MarketCandles.
	"""
	marketCandles(where: Where, limit: Int! = 0, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [MarketCandle!]!
	"""
	Returns a list of MarketCapLatestTotals.
	"""
	marketCapLatestTotals(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [MarketCapLatestTotals!]!
	"""
	Returns a list of MarketCapTotals.
	"""
	marketCapTotals(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [MarketCapTotals!]!
	"""
	Returns a list of MarketLatestMetrics.
	"""
	marketLatestMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [MarketLatestMetrics!]!
	"""
	Returns a list of MarketMetrics.
	"""
	marketMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [MarketMetric!]!
	"""
	Returns a list of MarketTopExchanges.
	"""
	marketTopExchanges(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["volume_24h_usd_desc"]): [MarketTopExchange!]!
	"""
	Returns a list of MarketTopExchangesVs.
	"""
	marketTopExchangesV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["volume_24h_usd_desc"]): [MarketTopExchangesV!]!
	"""
	Returns a list of MarketTopPairsVs.
	"""
	marketTopPairsV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["volume_24h_usd_desc"]): [MarketTopPairsV!]!
	"""
	Returns a list of MxAccounts.
	"""
	mxAccounts(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [MxAccount!]!
	"""
	Returns a list of MxMembers.
	"""
	mxMembers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [MxMember!]!
	"""
	Returns a list of MxUsers.
	"""
	mxUsers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [MxUser!]!
	"""
	Returns a list of Networks.
	"""
	networks(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_asc"]): [Network!]!
	"""
	Returns a list of Orders.
	"""
	orders(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [Order!]!
	"""
	Returns a list of OrderFills.
	"""
	orderFills(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [OrderFill!]!
	"""
	Returns a list of OrderFillsFees.
	"""
	orderFillsFees(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [OrderFillsFee!]!
	"""
	Returns a list of OrderSchedules.
	"""
	orderSchedules(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_ts_desc"]): [OrderSchedule!]!
	"""
	Returns a list of Panels.
	"""
	panels(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Panel!]!
	"""
	Returns a list of Payments.
	"""
	payments(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [Payment!]!
	"""
	Returns a list of PersonaInquiries.
	"""
	personaInquiries(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [PersonaInquiry!]!
	"""
	Returns a list of PlaidAccounts.
	"""
	plaidAccounts(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [PlaidAccount!]!
	"""
	Returns a list of PlaidMembers.
	"""
	plaidMembers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [PlaidMember!]!
	"""
	Returns a list of Portfolios.
	"""
	portfolios(where: Where, limit: Int! = 10, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Portfolio!]!
	"""
	Returns a list of PortfolioAssetsVs.
	"""
	portfolioAssetsV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [PortfolioAssetsV!]!
	"""
	Returns a list of PortfoliosVs.
	"""
	portfoliosV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [PortfoliosV!]!
	"""
	Returns a list of Providers.
	"""
	providers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [Provider!]!
	"""
	Returns a list of ProvidersAlias.
	"""
	providersAliases(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [ProvidersAlias!]!
	"""
	Returns a list of QoloAccounts.
	"""
	qoloAccounts(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [QoloAccount!]!
	"""
	Returns a list of QoloOutsideInstruments.
	"""
	qoloOutsideInstruments(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [QoloOutsideInstrument!]!
	"""
	Returns a list of QoloPersons.
	"""
	qoloPersons(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [QoloPerson!]!
	"""
	Returns a list of QoloWallets.
	"""
	qoloWallets(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [QoloWallet!]!
	"""
	Returns a list of Referrals.
	"""
	referrals(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Referral!]!
	"""
	Returns a list of Stacks.
	"""
	stacks(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_asc"]): [Stack!]!
	"""
	Returns a list of StackAllocations.
	"""
	stackAllocations(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["target_allocation_desc"]): [StackAllocation!]!
	"""
	Returns a list of StackAssetsVs.
	"""
	stackAssetsV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [StackAssetsV!]!
	"""
	Returns a list of StackDefaultsConfigs.
	"""
	stackDefaultsConfigs(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_desc"]): [StackDefaultsConfig!]!
	"""
	Returns a list of StackDefaultsCoinsConfigs.
	"""
	stackDefaultsCoinsConfigs(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["valid_from_asc"]): [StackDefaultsCoinsConfig!]!
	"""
	Returns a list of StackDefaultsCoinsConfigVs.
	"""
	stackDefaultsCoinsConfigV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["valid_from_asc"]): [StackDefaultsCoinsConfigV!]!
	"""
	Returns a list of StacksVs.
	"""
	stacksV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [StacksV!]!
	"""
	Returns a list of SubscriptionPlans.
	"""
	subscriptionPlans(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [SubscriptionPlan!]!
	"""
	Returns a list of SubscriptionsVs.
	"""
	subscriptionsV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["last_paid_at_desc"]): [SubscriptionsV!]!
	"""
	Returns a list of SubscriptionsTransactions.
	"""
	subscriptionsTransactions(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [SubscriptionsTransaction!]!
	"""
	Returns a list of Suitabilities.
	"""
	suitability(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Suitability!]!
	"""
	Returns a list of SuitabilityAnswers.
	"""
	suitabilityAnswers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["answer_order_asc"]): [SuitabilityAnswer!]!
	"""
	Returns a list of SuitabilityQuestions.
	"""
	suitabilityQuestions(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["question_order_asc"]): [SuitabilityQuestion!]!
	"""
	Returns a list of Transactions.
	"""
	transactions(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Transaction!]!
	"""
	Returns a list of TransactionsAllVs.
	"""
	transactionsAllV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [TransactionsAllV!]!
	"""
	Returns a list of TransactionsFees.
	"""
	transactionsFees(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_asc"]): [TransactionsFee!]!
	"""
	Returns a list of TransactionsSchedules.
	"""
	transactionsSchedules(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [TransactionsSchedule!]!
	"""
	Returns a list of TransactionsTransfers.
	"""
	transactionsTransfers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_asc"]): [TransactionsTransfer!]!
	"""
	Returns a list of Transfers.
	"""
	transfers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Transfer!]!
	"""
	Returns a list of TransfersFees.
	"""
	transfersFees(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [TransfersFee!]!
	"""
	Returns a list of TransfersLabels.
	"""
	transfersLabels(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [TransfersLabel!]!
	"""
	Returns a list of UpcomingFeatures.
	"""
	upcomingFeatures(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [UpcomingFeature!]!
	"""
	Returns a list of UpcomingFeaturesCountries.
	"""
	upcomingFeaturesCountries(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UpcomingFeaturesCountry!]!
	"""
	Returns a list of UsStates.
	"""
	usStates(where: Where, limit: Int! = 65, offset: Int! = 0, orderBy: [String!]! = ["state_asc"]): [UsState!]!
	"""
	Returns a list of UsZipCodes.
	"""
	usZipCodes(where: Where, limit: Int! = 20, offset: Int! = 0, orderBy: [String!]! = ["zip_code_asc"]): [UsZipCode!]!
	"""
	Returns a list of UserAgents.
	"""
	userAgents(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UserAgent!]!
	"""
	Returns a list of UsersFeatures.
	"""
	usersFeatures(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [UsersFeature!]!
	"""
	Returns a list of UsersNotifications.
	"""
	usersNotifications(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [UsersNotification!]!
	"""
	Returns a list of UsersProviders.
	"""
	usersProviders(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UsersProvider!]!
	"""
	Returns a list of UsersProvidersAssetsVs.
	"""
	usersProvidersAssetsV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [UsersProvidersAssetsV!]!
	"""
	Returns a list of UsersProvidersVs.
	"""
	usersProvidersV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [UsersProvidersV!]!
	"""
	Returns a list of UtmCodes.
	"""
	utmCodes(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [UtmCode!]!
	"""
	Returns a list of Wallets.
	"""
	wallets(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Wallet!]!
	"""
	Returns a list of WalletsVs.
	"""
	walletsV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["coin_internal_id_desc"]): [WalletsV!]!
	apiKeys(userId: UUID!, usersProvidersId: UUID!): [ApiKey!]!
	"""
	Returns a list of Balances.
	"""
	balances(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Balance!]!
	"""
	Returns a list of BalancesVs.
	"""
	balancesV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [BalancesV!]!
	"""
	Returns a list of UpcomingFeatureSignups.
	"""
	upcomingFeatureSignups(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UpcomingFeatureSignup!]!
	"""
	Returns a list of Users.
	"""
	users(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
	"""
	Returns a list of UserDelegates.
	"""
	userDelegates(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [UserDelegate!]!
	"""
	Returns a list of UserDetails.
	"""
	userDetails(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UserDetail!]!
	"""
	Returns a list of UserLoginHistories.
	"""
	userLoginHistories(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [UserLoginHistory!]!
	"""
	Returns a list of UsersVs.
	"""
	usersV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [UsersV!]!
}

type QuotesResponse {
	requestId: String!
	timestamp: Float!
	latency: Float!
	error: String!
	info: JSON!
	data: QuotesResponseData!
}

type QuotesResponseData {
	groupId: String!
	graphId: String!
	userId: String!
	quoteId: String!
	quoteTss: Float!
	quoteTse: Float!
	quoteBase: String!
	quoteSize: String!
	quoteQtyc: String!
	quoteQtyo: String!
	quoteRate: String!
	quoteInvr: String!
	quoteFees: QuotesResponseDataQuoteFees!
	quoteInfo: QuotesResponseDataQuoteInfo!
	quoteComp: [QuotesResponseDataQuoteComp!]!
}

type QuotesResponseDataQuoteComp {
	timestamp: Float!
	baseId: String!
	quoteId: String!
	exchangeId: String!
	marketRate: String!
	marketBpsd: String!
	marketFees: String!
}

type QuotesResponseDataQuoteFees {
	base: String
	fair: String
	user: String
}

type QuotesResponseDataQuoteInfo {
	cache: Boolean
	nodes: Float
	edges: Float
	paths: Float
	path1: String
	image: String
}

"""
Builder for [`RebalanceStackRequest`](struct.RebalanceStackRequest.html).
"""
input RebalanceStackRequestInput {
	userId: UUID
	stackId: UUID
	excludeCoinInternalIds: [String!]
	basisCoinInternalId: String
	forceRebalance: Boolean
}

"""
Connects users to other users who referred them
"""
type Referral {
	"""
	The status of the referral
	"""
	status: String!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier for the referred user in the Hedgehog database
	"""
	userId: UUID!
	"""
	The unique identifier for the referring user in the Hedgehog database
	"""
	referrerId: UUID!
	"""
	The amount of money the referrer gets when the user signs up
	"""
	amount: Int!
	"""
	The referral code that was used to refer the user
	"""
	referralCode: String
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
	referrer(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
Builder for [`Referral`](struct.Referral.html).
"""
input ReferralInput {
	"""
	The status of the referral
	"""
	status: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The unique identifier for the referred user in the Hedgehog database
	"""
	userId: UUID
	"""
	The unique identifier for the referring user in the Hedgehog database
	"""
	referrerId: UUID
	"""
	The amount of money the referrer gets when the user signs up
	"""
	amount: Int
	"""
	The referral code that was used to refer the user
	"""
	referralCode: String
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
}

type ReferralPayload {
	action: String!
	payload: Referral
	error: String
}

type Secret {
	key: String
	password: String
	secret: String
	accessToken: String
	refreshToken: String
	tokenType: String
	scope: String
}

"""
Builder for [`Secret`](struct.Secret.html).
"""
input SecretInput {
	key: String
	password: String
	secret: String
	accessToken: String
	refreshToken: String
	tokenType: String
	scope: String
}

"""
A stack is a collection of coins that are allocated to a portfolio
"""
type Stack {
	"""
	The unique identifier for this stack
	"""
	uuid: UUID!
	"""
	The human-readable name of the stack
	"""
	name: String!
	"""
	A description of the stack
	"""
	description: String!
	"""
	The user-designated target weight of the stack, if provided
	"""
	targetWeight: Numeric
	"""
	The strategy used to allocate the stack, eg MARKETCAP, TXCOUNT, ACTIVEADDRESSES
	"""
	strategy: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier of the portfolio this stack belongs to
	"""
	portfolioId: UUID!
	"""
	Whether this stack is the uncategorized stack
	"""
	isUncategorized: Boolean
	"""
	The unique identifier of the user that owns this stack
	"""
	userId: UUID!
	"""
	The unique identifier of the color associated with this stack
	"""
	colorId: UUID
	"""
	The unique identifier of the icon associated with this stack
	"""
	iconId: String
	"""
	Whether this stack is the default stack for the portfolio that receives undesignated deposits
	"""
	isDefault: Boolean!
	"""
	The unique identifier of the default stack composition this stack was created from
	"""
	stackDefaultId: UUID
	"""
	The error threshold at which the stack will be rebalanced, a value less than or equal to one
	"""
	rebalanceThreshold: Numeric!
	"""
	The schedule at which the stack will be rebalanced, a cron expression
	"""
	rebalanceSchedule: String
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	"""
	The date the stack was last rebalanced
	"""
	lastRebalancedAt: DateTime
	"""
	Indicates whether a stack is custodial or not, helping to differentiate between stacks managed internally or externally.
	"""
	isManaged: Boolean!
	colors(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [String!]!
	balances(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Balance!]!
	balancesV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [BalancesV!]!
	stackAllocations(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["target_allocation_desc"]): [StackAllocation!]!
	stackMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [StacksV!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
Allows users to set a strict target allocation for any coin in a stack,
eg, if the user wants to keep 10% of their funds in BTC regardless of strategy
"""
type StackAllocation {
	"""
	The unique identifier for this stack allocation
	"""
	uuid: UUID!
	"""
	The unique identifier of the associated stack
	"""
	stackId: UUID!
	"""
	The unique identifier of the associated coin
	"""
	coinId: UUID!
	"""
	The target allocation for this coin in the stack
	"""
	targetAllocation: Numeric
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier of the user owning this allocation
	"""
	userId: UUID!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
}

"""
Builder for [`StackAllocation`](struct.StackAllocation.html).
"""
input StackAllocationInput {
	"""
	The unique identifier for this stack allocation
	"""
	uuid: UUID
	"""
	The unique identifier of the associated stack
	"""
	stackId: UUID
	"""
	The unique identifier of the associated coin
	"""
	coinId: UUID
	"""
	The target allocation for this coin in the stack
	"""
	targetAllocation: Numeric
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The unique identifier of the user owning this allocation
	"""
	userId: UUID
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
}

type StackAllocationPayload {
	action: String!
	payload: StackAllocation
	error: String
}

type StackAssetWeight {
	assetId: String!
	userId: String!
	coinId: String!
	coinInternalId: String!
	assetBalance: String!
	assetPriceUsd: String!
	assetStrategyTotal: String!
	assetStrategy: String!
	currentWeight: String!
	currentValueUsd: String!
	targetWeight: String!
	targetWeightAdjusted: String!
	targetValueUsd: String!
	rebalanceRecommendation: String!
	rebalanceRecommendationUsd: String!
	assetError: String!
	stackError: String!
}

"""
Builder for [`StackAssetWeightRequest`](struct.StackAssetWeightRequest.html).
"""
input StackAssetWeightRequestInput {
	userId: UUID
	assetId: UUID
	stackId: UUID
}

"""
This model aggregates the balances of a given asset within a stack,
eg, all the BTC balances in your Hedgehog Total Stack
"""
type StackAssetsV {
	"""
	The unique identifier for the asset in the Hedgehog database
	"""
	assetId: UUID
	"""
	The unique identifier for the user in the Hedgehog database
	"""
	userId: UUID
	"""
	The unique identifier for the coin in the Hedgehog database
	"""
	coinId: UUID
	"""
	The unique identifier for the stack in the Hedgehog database
	"""
	stackId: UUID
	"""
	The unique human-readable identifier for the coin in the Hedgehog database
	"""
	coinInternalId: String
	"""
	The trading symbol generally used for the coin in the Hedgehog database
	"""
	coinSymbol: String
	"""
	The coin order for the associated coin
	"""
	coinOrder: Int
	"""
	Whether the user has hearted the asset
	"""
	isHearted: Boolean
	"""
	The balance of the asset in the stack
	"""
	balance: Numeric
	"""
	The balance of the asset in the stack in USD
	"""
	balanceUsd: Numeric
	"""
	The exchange rate of the asset in the stack in USD
	"""
	fxRateUsd: Numeric
	"""
	The number of balances that make up the asset in the stack
	"""
	balanceCount: Int
	"""
	The unique identifier for the stack allocation in the Hedgehog database
	"""
	stackAllocationId: UUID
	"""
	The target allocation of the asset in the stack
	"""
	targetAllocation: Numeric
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	marketCandles(where: Where, limit: Int! = 0, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [MarketCandle!]!
	marketLatestMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [MarketLatestMetrics!]!
	marketMetrics(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [MarketMetric!]!
	stack(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_asc"]): [Stack!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
Connects default stacks to their comprising coins
"""
type StackDefaultsCoinsConfig {
	"""
	The unique identifier for the stack defaults coins config in the Hedgehog database
	"""
	uuid: UUID!
	"""
	The unique identifier for the stack defaults config in the Hedgehog database
	"""
	stackDefaultsConfigId: UUID
	"""
	The unique identifier for the coin in the Hedgehog database
	"""
	coinId: UUID
	"""
	The date the coin was first included in the stack defaults config
	"""
	validFrom: NaiveDate!
	"""
	The date the coin was last included in the stack defaults config
	"""
	validUntil: NaiveDate!
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	stacks(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_desc"]): [StackDefaultsConfig!]!
}

"""
Builder for [`StackDefaultsCoinsConfig`](struct.StackDefaultsCoinsConfig.html).
"""
input StackDefaultsCoinsConfigInput {
	"""
	The unique identifier for the stack defaults coins config in the Hedgehog database
	"""
	uuid: UUID
	"""
	The unique identifier for the stack defaults config in the Hedgehog database
	"""
	stackDefaultsConfigId: UUID
	"""
	The unique identifier for the coin in the Hedgehog database
	"""
	coinId: UUID
	"""
	The date the coin was first included in the stack defaults config
	"""
	validFrom: NaiveDate
	"""
	The date the coin was last included in the stack defaults config
	"""
	validUntil: NaiveDate
}

type StackDefaultsCoinsConfigPayload {
	action: String!
	payload: StackDefaultsCoinsConfig
	error: String
}

"""
Connects default stacks to their comprising coins
"""
type StackDefaultsCoinsConfigV {
	"""
	The unique identifier for the stack defaults coins config in the Hedgehog database
	"""
	uuid: UUID
	"""
	The unique identifier for the stack defaults config in the Hedgehog database
	"""
	stackDefaultsConfigId: UUID
	"""
	The unique identifier for the coin in the Hedgehog database
	"""
	coinId: UUID
	"""
	The date the coin was first included in the stack defaults config
	"""
	validFrom: NaiveDate
	"""
	The date the coin was last included in the stack defaults config
	"""
	validUntil: NaiveDate
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	stacks(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_desc"]): [StackDefaultsConfig!]!
}

"""
A preset basket of assets that can be copied and consumed by users
"""
type StackDefaultsConfig {
	"""
	The unique identifier of the default stack
	"""
	uuid: UUID!
	"""
	The name of the default stack
	"""
	name: String!
	"""
	The description of the default stack
	"""
	description: String!
	"""
	The human-readable internal identifier of the default stack
	"""
	internalId: String!
	"""
	The icon of the default stack
	"""
	icon: String!
	"""
	The unique identifier of the selected color of the default stack
	"""
	colorId: UUID!
	"""
	The date from which the default stack was first offered
	"""
	validFrom: NaiveDate!
	"""
	The date from which the default stack was last offered
	"""
	validUntil: NaiveDate!
	"""
	The brand icon of the sponsored stack
	"""
	brandIcon: String
	"""
	The order in which the brand should be displayed in lists.
	"""
	brandOrder: Int
	"""
	The order in which the stack should be displayed in lists.
	"""
	stackOrder: Int
	coins(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["valid_from_asc"]): [StackDefaultsCoinsConfig!]!
	coinsView(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["valid_from_asc"]): [StackDefaultsCoinsConfigV!]!
}

"""
Builder for [`StackDefaultsConfig`](struct.StackDefaultsConfig.html).
"""
input StackDefaultsConfigInput {
	"""
	The unique identifier of the default stack
	"""
	uuid: UUID
	"""
	The name of the default stack
	"""
	name: String
	"""
	The description of the default stack
	"""
	description: String
	"""
	The human-readable internal identifier of the default stack
	"""
	internalId: String
	"""
	The icon of the default stack
	"""
	icon: String
	"""
	The unique identifier of the selected color of the default stack
	"""
	colorId: UUID
	"""
	The date from which the default stack was first offered
	"""
	validFrom: NaiveDate
	"""
	The date from which the default stack was last offered
	"""
	validUntil: NaiveDate
	"""
	The brand icon of the sponsored stack
	"""
	brandIcon: String
	"""
	The order in which the brand should be displayed in lists.
	"""
	brandOrder: Int
	"""
	The order in which the stack should be displayed in lists.
	"""
	stackOrder: Int
}

type StackDefaultsConfigPayload {
	action: String!
	payload: StackDefaultsConfig
	error: String
}

type StackGraphCandle {
	sourceTs: String!
	stackId: String!
	valueChangePercent: String!
	valueChangeUsd: String!
	valueOpenUsd: String!
	valueCloseUsd: String!
	valueLowUsd: String!
	valueHighUsd: String!
}

"""
Builder for [`StackGraphRequest`](struct.StackGraphRequest.html).
"""
input StackGraphRequestInput {
	userId: UUID
	stackId: UUID
	frequency: String
	startDate: String
	endDate: String
	candlesReturned: String
}

type StackGraphResponse {
	stackId: UUID!
	userId: UUID!
	frequency: String!
	startDate: String!
	endDate: String!
	candles: [StackGraphCandle!]!
}

"""
Builder for [`Stack`](struct.Stack.html).
"""
input StackInput {
	"""
	The unique identifier for this stack
	"""
	uuid: UUID
	"""
	The human-readable name of the stack
	"""
	name: String
	"""
	A description of the stack
	"""
	description: String
	"""
	The user-designated target weight of the stack, if provided
	"""
	targetWeight: Numeric
	"""
	The strategy used to allocate the stack, eg MARKETCAP, TXCOUNT, ACTIVEADDRESSES
	"""
	strategy: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The unique identifier of the portfolio this stack belongs to
	"""
	portfolioId: UUID
	"""
	Whether this stack is the uncategorized stack
	"""
	isUncategorized: Boolean
	"""
	The unique identifier of the user that owns this stack
	"""
	userId: UUID
	"""
	The unique identifier of the color associated with this stack
	"""
	colorId: UUID
	"""
	The unique identifier of the icon associated with this stack
	"""
	iconId: String
	"""
	Whether this stack is the default stack for the portfolio that receives undesignated deposits
	"""
	isDefault: Boolean
	"""
	The unique identifier of the default stack composition this stack was created from
	"""
	stackDefaultId: UUID
	"""
	The error threshold at which the stack will be rebalanced, a value less than or equal to one
	"""
	rebalanceThreshold: Numeric
	"""
	The schedule at which the stack will be rebalanced, a cron expression
	"""
	rebalanceSchedule: String
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	"""
	The date the stack was last rebalanced
	"""
	lastRebalancedAt: DateTime
	"""
	Indicates whether a stack is custodial or not, helping to differentiate between stacks managed internally or externally.
	"""
	isManaged: Boolean
}

type StackPayload {
	action: String!
	payload: Stack
	error: String
}

input StackProfitLossDetail {
	stackId: UUID!
	name: String!
	valueChangePercent: String!
	valueChangeUsd: String!
}

type StackWeight {
	stackId: String!
	userId: String!
	currentRating: String!
	targetRating: String!
	stackStrategyTotal: String!
	stackStrategyTotalAdjusted: String!
	stackStrategy: String!
	currentWeight: String!
	currentValueUsd: String!
	currentValueUsdAdjusted: String!
	targetWeight: String!
	targetValueUsd: String!
	rebalanceRecommendationUsd: String!
	stackError: String!
	portfolioError: String!
	assetWeights: [StackAssetWeight!]!
}

"""
Builder for [`StackWeightRequest`](struct.StackWeightRequest.html).
"""
input StackWeightRequestInput {
	userId: UUID
	stackId: UUID
}

"""
This model aggregates the total USD value and market cap and metrics of a given user stack
"""
type StacksV {
	"""
	The unique identifier for the user in the Hedgehog database
	"""
	userId: UUID
	"""
	The unique identifier for the portfolio in the Hedgehog database
	"""
	portfolioId: UUID
	"""
	The unique identifier for the stack in the Hedgehog database
	"""
	stackId: UUID
	"""
	The total USD value of the stack
	"""
	balanceUsd: Numeric
	"""
	The total USD value of the stack excluding MX accounts
	"""
	mxExcludedBalanceUsd: Numeric
	"""
	The total USD value of the stack including MX accounts
	"""
	mxIncludedBalanceUsd: Numeric
	"""
	The total USD value of the stack's market cap
	"""
	marketCapUsd: Numeric
	"""
	The total number of active addresses across all the assets in the stack
	"""
	activeAddresses: Numeric
	"""
	The total number of network transactions across all the assets in the stack
	"""
	txCount: Numeric
	"""
	The percentage change in the stack's USD value over the last 24 hours
	"""
	percentChange24Hours: Numeric
	"""
	The percentage change in the stack's USD value over the last week
	"""
	percentChange1Week: Numeric
	"""
	The percentage change in the stack's USD value over the last month
	"""
	percentChange1Month: Numeric
	"""
	The stack's percent total contribution to the portfolio value
	"""
	percentOfTotalUserPortfolioBalance: Numeric
	"""
	The stack's percent total contribution to the user's total balance
	"""
	percentOfTotalUserBalance: Numeric
	"""
	The total number of assets in the stack
	"""
	assetCount: Int
	"""
	The total number of balances in the stack
	"""
	balanceCount: Int
	"""
	The saved target allocation of the stack within the portfolio
	"""
	targetWeight: Numeric
	"""
	The strategy associated with the stack
	"""
	strategy: String
	"""
	The minimum error threshold for rebalancing the stack
	"""
	rebalanceThreshold: Numeric
	"""
	Indicates whether a stack is custodial or not, helping to differentiate between portfolios managed internally or externally.
	"""
	isManaged: Boolean!
	stack(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_asc"]): [Stack!]!
	stackAssetsV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [StackAssetsV!]!
}


type Subscription {
	latestAlias(userId: UUID): AliasPayload!
	latestAsset(userId: UUID): AssetPayload!
	latestBalancesLabel(userId: UUID): BalancesLabelPayload!
	latestCcxtExchanges(userId: UUID): CcxtExchangesPayload!
	latestCcxtMarketsByProvider(userId: UUID): CcxtMarketsByProviderPayload!
	latestCcxtMarket(userId: UUID): CcxtMarketPayload!
	latestCoin(userId: UUID): CoinPayload!
	latestCoinsCryptoGroup(userId: UUID): CoinsCryptoGroupPayload!
	latestCoinOffering(userId: UUID): CoinOfferingPayload!
	latestCoinPair(userId: UUID): CoinPairPayload!
	latestCoinResearch(userId: UUID): CoinResearchPayload!
	latestColor(userId: UUID): ColorPayload!
	latestContent(userId: UUID): ContentPayload!
	latestContract(userId: UUID): ContractPayload!
	latestCryptoEntity(userId: UUID): CryptoEntityPayload!
	latestCryptoGroup(userId: UUID): CryptoGroupPayload!
	latestCryptoMember(userId: UUID): CryptoMemberPayload!
	latestElement(userId: UUID): ElementPayload!
	latestFeature(userId: UUID): FeaturePayload!
	latestFee(userId: UUID): FeePayload!
	latestFxRate(userId: UUID): FxRatePayload!
	latestGeminiAccount(userId: UUID): GeminiAccountPayload!
	latestLabel(userId: UUID): LabelPayload!
	latestLink(userId: UUID): LinkPayload!
	latestLivePrice(userId: UUID): LivePricePayload!
	latestLot(userId: UUID): LotPayload!
	latestMarketCandle(userId: UUID): MarketCandlePayload!
	latestMarketMetric(userId: UUID): MarketMetricPayload!
	latestMarketTopExchange(userId: UUID): MarketTopExchangePayload!
	latestMxAccount(userId: UUID): MxAccountPayload!
	latestMxMember(userId: UUID): MxMemberPayload!
	latestMxUser(userId: UUID): MxUserPayload!
	latestNetwork(userId: UUID): NetworkPayload!
	latestNotification(userId: UUID): NotificationPayload!
	latestOrder(userId: UUID): OrderPayload!
	latestOrderFill(userId: UUID): OrderFillPayload!
	latestOrderFillsFee(userId: UUID): OrderFillsFeePayload!
	latestPanel(userId: UUID): PanelPayload!
	latestPayment(userId: UUID): PaymentPayload!
	latestPersonaInquiry(userId: UUID): PersonaInquiryPayload!
	latestPortfolio(userId: UUID): PortfolioPayload!
	latestPortfoliosCoin(userId: UUID): PortfoliosCoinPayload!
	latestProvider(userId: UUID): ProviderPayload!
	latestProvidersAlias(userId: UUID): ProvidersAliasPayload!
	latestQoloAccount(userId: UUID): QoloAccountPayload!
	latestQoloOutsideInstrument(userId: UUID): QoloOutsideInstrumentPayload!
	latestQoloPerson(userId: UUID): QoloPersonPayload!
	latestQoloWallet(userId: UUID): QoloWalletPayload!
	latestReferral(userId: UUID): ReferralPayload!
	latestOrderSchedule(userId: UUID): OrderSchedulePayload!
	latestStack(userId: UUID): StackPayload!
	latestStackAllocation(userId: UUID): StackAllocationPayload!
	latestStackDefaultsConfig(userId: UUID): StackDefaultsConfigPayload!
	latestStackDefaultsCoinsConfig(userId: UUID): StackDefaultsCoinsConfigPayload!
	latestSubscriptionsTransaction(userId: UUID): SubscriptionsTransactionPayload!
	latestSuitability(userId: UUID): SuitabilityPayload!
	latestSuitabilityAnswer(userId: UUID): SuitabilityAnswerPayload!
	latestSuitabilityQuestion(userId: UUID): SuitabilityQuestionPayload!
	latestTransaction(userId: UUID): TransactionPayload!
	latestTransactionsFee(userId: UUID): TransactionsFeePayload!
	latestTransactionsSchedule(userId: UUID): TransactionsSchedulePayload!
	latestTransfer(userId: UUID): TransferPayload!
	latestTransfersFee(userId: UUID): TransfersFeePayload!
	latestTransfersLabel(userId: UUID): TransfersLabelPayload!
	latestUpcomingFeature(userId: UUID): UpcomingFeaturePayload!
	latestUserAgent(userId: UUID): UserAgentPayload!
	latestUsersFeature(userId: UUID): UsersFeaturePayload!
	latestUsersNotification(userId: UUID): UsersNotificationPayload!
	latestUsersProvider(userId: UUID): UsersProviderPayload!
	latestWallet(userId: UUID): WalletPayload!
	latestApiKey(userId: UUID): ApiKeyPayload!
	latestBalance(userId: UUID): BalancePayload!
	latestUpcomingFeatureSignup(userId: UUID): UpcomingFeatureSignupPayload!
	latestUser(userId: UUID): UserPayload!
	latestUserDetail(userId: UUID): UserDetailPayload!
	latestUserLoginHistory(userId: UUID): UserLoginHistoryPayload!
}

"""
This table encodes the available subscription pricing options that users can pay
"""
type SubscriptionPlan {
	"""
	The subscription's unique identifier
	"""
	uuid: UUID!
	"""
	The subscription's unique name
	"""
	name: String!
	"""
	The annual percent fee charged to the customer. The formula to charge a monthly fee on this amount is:
	`monthly_average_portfolio_value * annual_percent_management_fee / 12 * days_account_active_this_month / days_in_this_month`
	"""
	annualPercentManagementFee: Numeric
	"""
	The upfront cost the user must pay on signup
	"""
	upfrontCostUsd: Numeric
	"""
	The date and time in UTC that the table entry was created
	"""
	createdAt: DateTime!
	"""
	The date and time in UTC that the table entry was last updated
	"""
	updatedAt: DateTime!
}

"""
Builder for [`SubscriptionPlan`](struct.SubscriptionPlan.html).
"""
input SubscriptionPlanInput {
	"""
	The subscription's unique identifier
	"""
	uuid: UUID
	"""
	The subscription's unique name
	"""
	name: String
	"""
	The annual percent fee charged to the customer. The formula to charge a monthly fee on this amount is:
	`monthly_average_portfolio_value * annual_percent_management_fee / 12 * days_account_active_this_month / days_in_this_month`
	"""
	annualPercentManagementFee: Numeric
	"""
	The upfront cost the user must pay on signup
	"""
	upfrontCostUsd: Numeric
	"""
	The date and time in UTC that the table entry was created
	"""
	createdAt: DateTime
	"""
	The date and time in UTC that the table entry was last updated
	"""
	updatedAt: DateTime
}

"""
A SubscriptionsTransaction connects a user's subscription to the transactions they have paid to cover the cost
"""
type SubscriptionsTransaction {
	"""
	The unique identifier of the subscription transaction connection row
	"""
	uuid: UUID!
	"""
	The unique identifier of the subscription that is being paid
	"""
	subscriptionId: UUID!
	"""
	The unique identifier of the transaction that was paid for a subscription
	"""
	transactionId: UUID!
	userId: UUID!
	"""
	The date and time in UTC that the table entry was created
	"""
	createdAt: DateTime!
	"""
	The date and time in UTC that the table entry was last updated
	"""
	updatedAt: DateTime!
	deletedAt: DateTime
	transactions(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Transaction!]!
}

"""
Builder for [`SubscriptionsTransaction`](struct.SubscriptionsTransaction.html).
"""
input SubscriptionsTransactionInput {
	"""
	The unique identifier of the subscription transaction connection row
	"""
	uuid: UUID
	"""
	The unique identifier of the subscription that is being paid
	"""
	subscriptionId: UUID
	"""
	The unique identifier of the transaction that was paid for a subscription
	"""
	transactionId: UUID
	userId: UUID
	"""
	The date and time in UTC that the table entry was created
	"""
	createdAt: DateTime
	"""
	The date and time in UTC that the table entry was last updated
	"""
	updatedAt: DateTime
	deletedAt: DateTime
}

type SubscriptionsTransactionPayload {
	action: String!
	payload: SubscriptionsTransaction
	error: String
}

"""
This table shows a user's current subscription plan, and when a user last paid their subscription fee
"""
type SubscriptionsV {
	"""
	The unique identifier of the subscription's related user
	"""
	userId: UUID
	"""
	The unique identifier of the user's chosen subscription
	"""
	subscriptionId: UUID
	"""
	The subscription's unique name
	"""
	subscriptionName: String
	"""
	The created_at of the most recent subscriptions_transactions entry
	"""
	lastPaidAt: DateTime
	subscription(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [SubscriptionPlan!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
Connects suitability answers to suitability quesions and the user who answered them
"""
type Suitability {
	"""
	The unique identifier for this user response to the suitability questionnaire
	"""
	uuid: UUID!
	"""
	The unique identifier of the associated user
	"""
	userId: UUID!
	"""
	The unique identifier of the associated suitability answer
	"""
	answerId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-delete in the database
	"""
	deletedAt: DateTime
	suitabilityAnswer(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["answer_order_asc"]): [SuitabilityAnswer!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
A possible answer to a suitability question
"""
type SuitabilityAnswer {
	"""
	The unique identifier for the suitability answer in the Hedgehog database
	"""
	uuid: UUID!
	"""
	The unique identifier for the suitability question in the Hedgehog database
	"""
	questionId: UUID!
	"""
	The order of the answer in the list of answers for the question
	"""
	answerOrder: Int!
	"""
	The answer to the question
	"""
	answer: String!
	"""
	Whether the answer is valid or not
	"""
	isValid: Boolean!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier for the suitability question in the Hedgehog database to be displayed to the user if this answer is chosen
	"""
	nextQuestionId: UUID
	suitabilityQuestion(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["question_order_asc"]): [SuitabilityQuestion!]!
}

"""
Builder for [`SuitabilityAnswer`](struct.SuitabilityAnswer.html).
"""
input SuitabilityAnswerInput {
	"""
	The unique identifier for the suitability answer in the Hedgehog database
	"""
	uuid: UUID
	"""
	The unique identifier for the suitability question in the Hedgehog database
	"""
	questionId: UUID
	"""
	The order of the answer in the list of answers for the question
	"""
	answerOrder: Int
	"""
	The answer to the question
	"""
	answer: String
	"""
	Whether the answer is valid or not
	"""
	isValid: Boolean
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The unique identifier for the suitability question in the Hedgehog database to be displayed to the user if this answer is chosen
	"""
	nextQuestionId: UUID
}

type SuitabilityAnswerPayload {
	action: String!
	payload: SuitabilityAnswer
	error: String
}

type SuitabilityPayload {
	action: String!
	payload: Suitability
	error: String
}

"""
A question that clients must answer to receive investment advice
"""
type SuitabilityQuestion {
	"""
	The unique identifier for the suitability question in the Hedgehog database
	"""
	uuid: UUID!
	"""
	The name of the question
	"""
	questionName: String!
	"""
	The order of the question in the list of questions
	"""
	questionOrder: Int!
	"""
	The question textual copy
	"""
	question: String!
	"""
	The question description
	"""
	questionDescription: String
	"""
	The question type, indicates render as radio button, slider, etc
	"""
	questionType: String!
	"""
	Whether the question is valid or not
	"""
	isValid: Boolean!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	suitabilityAnswers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["answer_order_asc"]): [SuitabilityAnswer!]!
}

"""
Builder for [`SuitabilityQuestion`](struct.SuitabilityQuestion.html).
"""
input SuitabilityQuestionInput {
	"""
	The unique identifier for the suitability question in the Hedgehog database
	"""
	uuid: UUID
	"""
	The name of the question
	"""
	questionName: String
	"""
	The order of the question in the list of questions
	"""
	questionOrder: Int
	"""
	The question textual copy
	"""
	question: String
	"""
	The question description
	"""
	questionDescription: String
	"""
	The question type, indicates render as radio button, slider, etc
	"""
	questionType: String
	"""
	Whether the question is valid or not
	"""
	isValid: Boolean
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type SuitabilityQuestionPayload {
	action: String!
	payload: SuitabilityQuestion
	error: String
}

type SyncBankInstitutionViaPlaidResponse {
	accountsUpdated: Int!
	accountsFailed: Int!
}

"""
Builder for [`TotalReturnComparisonRequest`](struct.TotalReturnComparisonRequest.html).
"""
input TotalReturnComparisonRequestInput {
	initialDeposit: String
	repeatingDepositAmount: String
	repeatingDepositSchedule: String
	rebalanceThreshold: String
	rebalanceSchedule: String
	riskProtectionTargetPct: String
	strategy: String
	startDate: String
	endDate: String
	stackDefaultsConfigId: String
	coinInternalIds: [String!]
	stackDefaultsConfigIdB: String
	coinInternalIdsB: [String!]
	includeAssets: String
	candlesReturned: String
}

"""
The root total return response object for a given set of coins
"""
type TotalReturnComparisonResponse {
	"""
	The total return data for the base coin set (set A).
	"""
	a: TotalReturnComparisonRoot!
	"""
	The total return data for the compared coin set (set B).
	"""
	b: TotalReturnComparisonRoot!
}

"""
The root total return response object for a given set of coins
"""
type TotalReturnComparisonRoot {
	"""
	The requested `startDate` for the returned information.
	"""
	startDate: String!
	"""
	The requested `endDate` for the returned information.
	"""
	endDate: String!
	"""
	The requested `strategy` for the returned information.
	"""
	strategy: String!
	"""
	The requested `stackDefaultsConfigId` for the returned information, if any.
	"""
	stackDefaultsConfigId: String
	"""
	The requested `coinInternalIds` for the returned information, if any.
	"""
	coinInternalIds: [String!]
	"""
	The requested `initialDeposit` for the returned information.
	"""
	initialDeposit: String!
	"""
	The requested `repeatingDepositAmount` for the returned information.
	"""
	repeatingDepositAmount: String!
	"""
	The requested `repeatingDepositSchedule` for the returned information.
	"""
	repeatingDepositSchedule: String!
	"""
	The requested `rebalanceThreshold` for the returned information.
	"""
	rebalanceThreshold: String!
	"""
	The requested `rebalanceSchedule` for the returned information.
	"""
	rebalanceSchedule: String!
	"""
	The percentage total return of the portfolio normalized onto an annual time-period, eg 5% return for year.
	"""
	annualizedReturn: String!
	"""
	The maximum peak-to-trough movement from `startDate` to `endDate`. A new high will rebase future drawdowns to the latest high.
	"""
	maxDrawdown: String!
	"""
	The average return of a model portfolio that includes only 10-year US Treasury bonds.
	"""
	riskFreeRate: String!
	"""
	A ratio that indicates a rough estimate of the risk-to-reward ratio. More information can be found [here](https://www.investopedia.com/terms/s/sharperatio.asp).
	"""
	sharpeRatio: String!
	"""
	The average return of the portfolio, taking into account the timing and size of deposits and withdrawals.
	"""
	timeWeightedReturn: String!
	"""
	An array of `TotalReturnEntryInfo`, each representing one day of performance for all the assets in the portfolio
	"""
	totalReturnEntries: [TotalReturnEntryInfo!]!
}

"""
The entry inside the TotalReturnResponse representing one day of performance for all the assets in the portfolio
"""
type TotalReturnEntry {
	"""
	The normalized timestamp provided by our third-party data providers.
	"""
	sourceTs: String!
	"""
	The strategy requested for allocating funds to different currencies: MARKET_CAP_USD, TX_COUNT, or ACTIVE_ADDRESSES.
	More strategies may be added in the future.
	"""
	stackStrategy: String!
	"""
	The sum of all `market_metric` totals for each coin in the proposed portfolio, based on the selected `strategy`.
	"""
	stackStrategyTotal: String!
	"""
	The USD value of any deposits added on the current day.
	"""
	depositAmountUsd: String!
	"""
	The USD value of all deposits added from `startDate` to the current day.
	"""
	depositTotalUsd: String!
	"""
	The USD value of any fees assessed added on the current day.
	"""
	feeAmountUsd: String!
	"""
	The USD value of all fees assessed from `startDate` to the current day.
	"""
	feeTotalUsd: String!
	"""
	The USD value of any losses or gains in comparison to the `deposit_total_usd`.
	"""
	totalReturnUsd: String!
	"""
	The USD value of all assets in the stack at the end of the current day.
	"""
	stackValueTotalUsd: String!
	"""
	The percentage total return of the portfolio normalized onto an annual time-period, eg 5% return for year.
	"""
	annualizedReturn: String!
	"""
	The number of days that have elapsed between the current day and `startDate`.
	"""
	elapsed: String!
	"""
	The maximum peak-to-trough movement from `startDate` to the current date. A new high will rebase future drawdowns to the latest high.
	"""
	maxDrawdown: String!
	"""
	The average return of the portfolio less the risk-free rate.
	"""
	meanExcessReturn: String!
	"""
	The average return of a model portfolio that includes only 10-year US Treasury bonds.
	"""
	riskFreeRate: String!
	"""
	A ratio that indicates a rough estimate of the risk-to-reward ratio. More information can be found [here](https://www.investopedia.com/terms/s/sharperatio.asp).
	"""
	sharpeRatio: String!
	"""
	The average return of the portfolio, taking into account the timing and size of deposits and withdrawals.
	"""
	timeWeightedReturn: String!
	"""
	The yield of a 10-year US Treasury bond on the current day.
	"""
	usTreasuryYield: String!
	"""
	The mean-squared variance of the excess-return, a rough estimate of portfolio risk.
	"""
	variance: String!
	"""
	The percentage change between the previous and current day.
	"""
	valueChangePercent: String!
	"""
	The amount change between the previous and current day.
	"""
	valueChangeUsd: String!
	"""
	Whether a set of rebalancing transactions were simulated on the current day.
	"""
	rebalanced: Boolean!
	"""
	A list of assets and their allocation changes and recommendations on the current day.
	"""
	assets: [TotalReturnEntryCoinInfo!]
}

type TotalReturnEntryCoinInfo {
	sourceTs: String!
	coinInternalId: String!
	fxRateUsd: String!
	assetStrategy: String!
	assetStrategyTotal: String!
	targetWeight: String!
	assetBalance: String!
	assetBalanceChange: String!
	currentValueUsd: String!
	currentWeight: String!
	rebalanceRecommendation: String!
	rebalanceRecommendationUsd: String!
	assetError: String!
	stackError: String!
}

"""
The comparison object inside every total return entry object which holds the computed
comparison information relative to the base total return data
"""
type TotalReturnEntryComparison {
	trackingError: String!
}

"""
The entry inside the TotalReturnRoot representing one day of performance for all the assets in the portfolio
"""
type TotalReturnEntryInfo {
	"""
	The normalized timestamp provided by our third-party data providers.
	"""
	sourceTs: String!
	"""
	The strategy requested for allocating funds to different currencies: MARKET_CAP_USD, TX_COUNT, or ACTIVE_ADDRESSES.
	More strategies may be added in the future.
	"""
	stackStrategy: String!
	"""
	The sum of all `market_metric` totals for each coin in the proposed portfolio, based on the selected `strategy`.
	"""
	stackStrategyTotal: String!
	"""
	The USD value of any deposits added on the current day.
	"""
	depositAmountUsd: String!
	"""
	The USD value of all deposits added from `startDate` to the current day.
	"""
	depositTotalUsd: String!
	"""
	The USD value of any fees assessed added on the current day.
	"""
	feeAmountUsd: String!
	"""
	The USD value of all fees assessed from `startDate` to the current day.
	"""
	feeTotalUsd: String!
	"""
	The USD value of any losses or gains in comparison to the `deposit_total_usd`.
	"""
	totalReturnUsd: String!
	"""
	The USD value of all assets in the stack at the end of the current day.
	"""
	stackValueTotalUsd: String!
	"""
	The percentage total return of the portfolio normalized onto an annual time-period, eg 5% return for year.
	"""
	annualizedReturn: String!
	"""
	The number of days that have elapsed between the current day and `startDate`.
	"""
	elapsed: String!
	"""
	The maximum peak-to-trough movement from `startDate` to the current date. A new high will rebase future drawdowns to the latest high.
	"""
	maxDrawdown: String!
	"""
	The average return of the portfolio less the risk-free rate.
	"""
	meanExcessReturn: String!
	"""
	The average return of a model portfolio that includes only 10-year US Treasury bonds.
	"""
	riskFreeRate: String!
	"""
	A ratio that indicates a rough estimate of the risk-to-reward ratio. More information can be found [here](https://www.investopedia.com/terms/s/sharperatio.asp).
	"""
	sharpeRatio: String!
	"""
	The average return of the portfolio, taking into account the timing and size of deposits and withdrawals.
	"""
	timeWeightedReturn: String!
	"""
	The yield of a 10-year US Treasury bond on the current day.
	"""
	usTreasuryYield: String!
	"""
	The mean-squared variance of the excess-return, a rough estimate of portfolio risk.
	"""
	variance: String!
	"""
	The percentage change between the previous and current day.
	"""
	valueChangePercent: String!
	"""
	The amount change between the previous and current day.
	"""
	valueChangeUsd: String!
	"""
	Whether a set of rebalancing transactions were simulated on the current day.
	"""
	rebalanced: Boolean!
	"""
	A list of assets and their allocation changes and recommendations on the current day.
	"""
	assets: [TotalReturnEntryCoinInfo!]
	"""
	Comparison data relative to the base total return object, when applicable.
	"""
	comparison: TotalReturnEntryComparison
}

"""
Builder for [`TotalReturnRequest`](struct.TotalReturnRequest.html).
"""
input TotalReturnRequestInput {
	initialDeposit: String
	repeatingDepositAmount: String
	repeatingDepositSchedule: String
	rebalanceThreshold: String
	rebalanceSchedule: String
	riskProtectionTargetPct: String
	strategy: String
	startDate: String
	endDate: String
	stackDefaultsConfigId: String
	coinInternalIds: [String!]
	includeAssets: String
	candlesReturned: String
}

"""
The response wrapper for total return data. Users may select either a `stack_defaults_config_id` or a list of `coin_internal_ids`
along with initialization data to see various return metrics over time for a portfolio constructed of the given coins
"""
type TotalReturnResponse {
	"""
	The requested `startDate` for the returned information.
	"""
	startDate: String!
	"""
	The requested `endDate` for the returned information.
	"""
	endDate: String!
	"""
	The requested `strategy` for the returned information.
	"""
	strategy: String!
	"""
	The requested `stackDefaultsConfigId` for the returned information, if any.
	"""
	stackDefaultsConfigId: String
	"""
	The requested `coinInternalIds` for the returned information, if any.
	"""
	coinInternalIds: [String!]
	"""
	The requested `initialDeposit` for the returned information.
	"""
	initialDeposit: String!
	"""
	The requested `repeatingDepositAmount` for the returned information.
	"""
	repeatingDepositAmount: String!
	"""
	The requested `repeatingDepositSchedule` for the returned information.
	"""
	repeatingDepositSchedule: String!
	"""
	The requested `rebalanceThreshold` for the returned information.
	"""
	rebalanceThreshold: String!
	"""
	The requested `rebalanceSchedule` for the returned information.
	"""
	rebalanceSchedule: String!
	"""
	The percentage total return of the portfolio normalized onto an annual time-period, eg 5% return for year.
	"""
	annualizedReturn: String!
	"""
	The maximum peak-to-trough movement from `startDate` to `endDate`. A new high will rebase future drawdowns to the latest high.
	"""
	maxDrawdown: String!
	"""
	The average return of a model portfolio that includes only 10-year US Treasury bonds.
	"""
	riskFreeRate: String!
	"""
	A ratio that indicates a rough estimate of the risk-to-reward ratio. More information can be found [here](https://www.investopedia.com/terms/s/sharperatio.asp).
	"""
	sharpeRatio: String!
	"""
	The average return of the portfolio, taking into account the timing and size of deposits and withdrawals.
	"""
	timeWeightedReturn: String!
	"""
	An array of `TotalReturnEntry`, each representing one day of performance for all the assets in the portfolio
	"""
	totalReturnEntries: [TotalReturnEntry!]!
}

"""
A transfer of a single currency from point a to point b
either on the same provider or across providers
or even on the same network or across networks
"""
type Transaction {
	"""
	The unique identifier for the transaction
	"""
	uuid: UUID!
	"""
	The user associated with the transaction
	"""
	userId: UUID!
	"""
	The coin tranferred in the transaction
	"""
	coinId: UUID!
	"""
	The users provider that initiates or tracks the transaction
	"""
	usersProvidersId: UUID!
	"""
	The network the transaction occurred on
	"""
	networkId: UUID
	"""
	The contract the transaction occurred on
	"""
	contractId: UUID
	"""
	The balance the transaction was debited from
	"""
	debitBalanceId: UUID!
	"""
	The balance the transaction was credited to
	"""
	creditBalanceId: UUID!
	"""
	The api key used to initiate the transaction, if applicable
	"""
	apiKeyId: UUID
	"""
	The amount of the transaction
	"""
	amount: Numeric!
	"""
	The source reporting the transaction data
	"""
	source: String!
	"""
	The timestamp of the transaction
	"""
	sourceTs: DateTime!
	"""
	Whether the transaction was a withdrawal or deposit
	"""
	isWithdrawal: Boolean!
	"""
	The status of the transaction, ie pending, completed, failed
	"""
	transactionStatus: String!
	"""
	A comment attached to the transaction
	"""
	comment: String
	"""
	The transaction hash of the transaction as saved on the network
	"""
	txHash: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The id of the transaction in the external source
	"""
	externalId: String
	"""
	The client-determined id of the transaction in the external source
	"""
	clientExternalId: String
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	"""
	Whether the row is hidden from the user
	"""
	isHidden: Boolean
	"""
	The ID of the user that initiated the order
	"""
	requesterId: UUID
	debitBalancesV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [BalancesV!]!
	creditBalancesV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [BalancesV!]!
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	contract(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Contract!]!
	network(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_asc"]): [Network!]!
	transactionsSchedules(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [TransactionsSchedule!]!
	fees(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_asc"]): [TransactionsFee!]!
	transfers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_asc"]): [TransactionsTransfer!]!
	usersProvider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UsersProvider!]!
	usersProvidersV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [UsersProvidersV!]!
}

type TransactionPayload {
	action: String!
	payload: Transaction
	error: String
}

"""
A view combining transactions with their coin and provider information
"""
type TransactionsAllV {
	"""
	The unique identifier for this transaction
	"""
	uuid: UUID
	"""
	The unique identifier for the user who initiated this transaction
	"""
	userId: UUID
	"""
	The unique identifier for the user's provider who initiated this transaction
	"""
	usersProvidersId: UUID
	"""
	The unique identifier for the network this transaction was initiated on
	"""
	networkId: UUID
	"""
	The unique identifier for the contract this transaction was initiated using
	"""
	contractId: UUID
	apiKeyId: UUID
	source: String
	sourceTs: DateTime
	transactionType: String
	coinId: UUID
	quantityTransacted: Numeric
	basisCoinId: UUID
	basisAmount: Numeric
	transactionStatus: String
	externalId: String
	clientExternalId: String
	debitBalanceId: UUID
	creditBalanceId: UUID
	creditUsersProvidersId: UUID
	debitUsersProvidersId: UUID
	creditProviderInternalId: String
	debitProviderInternalId: String
	creditCoinInternalId: String
	debitCoinInternalId: String
	creditStackId: UUID
	debitStackId: UUID
	"""
	The ID of the user that initiated the order
	"""
	requesterId: UUID
	createdAt: DateTime
	updatedAt: DateTime
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
	usersProvider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UsersProvider!]!
	network(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_asc"]): [Network!]!
	contract(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Contract!]!
	debitStackV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [StacksV!]!
	creditStackV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [StacksV!]!
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	basisCoin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	debitBalancesV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [BalancesV!]!
	creditBalancesV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [BalancesV!]!
}

"""
Connects the transactions table with the fees table
"""
type TransactionsFee {
	"""
	The unique identifier for this transaction fee
	"""
	uuid: UUID!
	"""
	The unique identifier of the associated user
	"""
	userId: UUID!
	"""
	The unique identifier of the associated transaction
	"""
	transactionId: UUID!
	"""
	The unique identifier of the associated fee
	"""
	feeId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-delete in the database
	"""
	deletedAt: DateTime
	fee(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Fee!]!
	transaction(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Transaction!]!
}

type TransactionsFeePayload {
	action: String!
	payload: TransactionsFee
	error: String
}

"""
Sets a date and interval for executing a proposed transaction
"""
type TransactionsSchedule {
	"""
	The unique identifier of the transaction schedule
	"""
	uuid: UUID!
	"""
	The unique identifier of the transaction that is being scheduled
	"""
	transactionId: UUID!
	"""
	The unique identifier of the user that is scheduling the transaction
	"""
	userId: UUID!
	"""
	The date and time the transaction is scheduled to execute
	"""
	orderTs: DateTime!
	"""
	The cron expression that defines the interval for executing the transaction
	"""
	schedule: String!
	"""
	Whether or not the schedule is active
	"""
	isActive: Boolean!
	"""
	The number of remaining times the transaction should be executed
	"""
	repetitions: Int
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was deleted in the database
	"""
	deletedAt: DateTime
	transaction(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Transaction!]!
}

type TransactionsSchedulePayload {
	action: String!
	payload: TransactionsSchedule
	error: String
}

"""
A table that connects transfers to transactions
"""
type TransactionsTransfer {
	"""
	The unique identifier of the transactions_transfers connection
	"""
	uuid: UUID!
	"""
	The unique identifier of the associated user
	"""
	userId: UUID!
	"""
	The unique identifier of the associated transaction
	"""
	transactionId: UUID!
	"""
	The unique identifier of the associated transfer
	"""
	transferId: UUID!
	"""
	The date and time in UTC the row was created
	"""
	createdAt: DateTime!
	"""
	The date and time in UTC the row was last updated
	"""
	updatedAt: DateTime!
	deletedAt: DateTime
	transfer(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Transfer!]!
}

type TransactonsScheduleAndTransactions {
	"""
	The upserted transactions schedule
	"""
	transactionsSchedule: TransactionsSchedule!
	"""
	The executed transaction
	"""
	executedTransaction: Transaction
	"""
	The next scheduled transaction for the related schedule
	"""
	scheduledTransaction: Transaction
}

"""
The fundamental unit of money movement. all credits and debits on individual accounts
at the most granular level should be recorded as a transfers
"""
type Transfer {
	"""
	The unique identifier for this transfer
	"""
	uuid: UUID!
	"""
	The unique identifier of the associated user
	"""
	userId: UUID!
	"""
	The unique identifier of the associated balance
	"""
	balanceId: UUID!
	"""
	Whether this transfer is a credit or debit
	"""
	isCredit: Boolean!
	"""
	The amount of the transfer
	"""
	amount: Numeric!
	"""
	The unique identifier of the coin used as the cost basis for the transfer
	"""
	basisCoinId: UUID!
	"""
	The amount of the transfer denominated in the cost basis coin
	"""
	basisAmount: Numeric!
	"""
	The transaction hash of the transfer
	"""
	txHash: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	"""
	The timestamp of the source data
	"""
	sourceTs: DateTime!
	balance(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Balance!]!
	basisCoin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	labels(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [TransfersLabel!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

type TransferPayload {
	action: String!
	payload: Transfer
	error: String
}

"""
A table that connects transfers to fees
"""
type TransfersFee {
	"""
	The unique identifier for this transfer fee
	"""
	uuid: UUID!
	"""
	The unique identifier of the associated user
	"""
	userId: UUID!
	"""
	The unique identifier of the associated transfer
	"""
	transferId: UUID!
	"""
	The unique identifier of the associated fee
	"""
	feeId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was deleted in the database
	"""
	deletedAt: DateTime
}

type TransfersFeePayload {
	action: String!
	payload: TransfersFee
	error: String
}

"""
A table that connects transfers to labels
"""
type TransfersLabel {
	"""
	The unique identifier for this transfer label
	"""
	uuid: UUID!
	"""
	The unique identifier of the associated transfer
	"""
	transferId: UUID!
	"""
	The unique identifier of the associated label
	"""
	labelId: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
}

type TransfersLabelPayload {
	action: String!
	payload: TransfersLabel
	error: String
}

"""
A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
Strings within GraphQL. UUIDs are used to assign unique identifiers to
entities without requiring a central allocating authority.

# References

* [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
"""
scalar UUID

"""
A feature that is planned for the future
"""
type UpcomingFeature {
	"""
	The unique identifier for this upcoming feature
	"""
	uuid: UUID!
	"""
	The name of the feature
	"""
	name: String
	"""
	The current status of the feature, ie indev, stage, beta, or prod
	"""
	status: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	countries(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UpcomingFeaturesCountry!]!
}

"""
Builder for [`UpcomingFeature`](struct.UpcomingFeature.html).
"""
input UpcomingFeatureInput {
	"""
	The unique identifier for this upcoming feature
	"""
	uuid: UUID
	"""
	The name of the feature
	"""
	name: String
	"""
	The current status of the feature, ie indev, stage, beta, or prod
	"""
	status: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type UpcomingFeaturePayload {
	action: String!
	payload: UpcomingFeature
	error: String
}

"""
An email signup for an upcoming feature
"""
type UpcomingFeatureSignup {
	"""
	The unique identifier for this signup
	"""
	uuid: UUID!
	"""
	The unique identifier of the associated upcoming feature
	"""
	upcomingFeatureUuid: UUID
	"""
	The email address of the user who signed up
	"""
	email: CiText
	"""
	The current status of the feature
	"""
	status: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	utmCodeId: UUID
	"""
	The unique identifier for the user agent extracted from the signup request
	"""
	userAgentId: UUID
	upcomingFeature(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [UpcomingFeature!]!
	userAgents(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UserAgent!]!
	utmCodes(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [UtmCode!]!
}

"""
Builder for [`UpcomingFeatureSignup`](struct.UpcomingFeatureSignup.html).
"""
input UpcomingFeatureSignupInput {
	"""
	The unique identifier for this signup
	"""
	uuid: UUID
	"""
	The unique identifier of the associated upcoming feature
	"""
	upcomingFeatureUuid: UUID
	"""
	The email address of the user who signed up
	"""
	email: CiText
	"""
	The current status of the feature
	"""
	status: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The date the row was soft-deleted in the database
	"""
	utmCodeId: UUID
	"""
	The unique identifier for the user agent extracted from the signup request
	"""
	userAgentId: UUID
}

type UpcomingFeatureSignupPayload {
	action: String!
	payload: UpcomingFeatureSignup
	error: String
}

"""
A view to connect upcoming features and the countries in which they're available
"""
type UpcomingFeaturesCountry {
	"""
	The unique identifier for this upcoming feature country connection
	"""
	uuid: UUID!
	"""
	The unique identifier of the associated upcoming feature
	"""
	upcomingFeatureId: UUID!
	"""
	The unique identifier of the associated country
	"""
	countryId: UUID!
	"""
	Whether or not the upcoming feature is available in the associated country
	"""
	isHedgehogAvailable: Boolean
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
}

"""
A list of state codes
"""
type UsState {
	"""
	The unique identifier for this state
	"""
	uuid: UUID!
	"""
	The two-letter state code
	"""
	state: String!
	"""
	The full name of the state
	"""
	stateFullName: String!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
}

"""
Used to fill in missing data from persona
"""
type UsZipCode {
	"""
	The unique identifier for this zip code
	"""
	uuid: UUID!
	"""
	The zip code
	"""
	zipCode: String!
	"""
	The city name
	"""
	city: String!
	"""
	The state code
	"""
	usState: String!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
}

"""
The main user model that connects to all the relevant models.
It is connected to a cognito identity via the user.cognito_id and cognito.sub_id.
"""
type User {
	"""
	The unique identifier for the user
	"""
	uuid: UUID!
	"""
	The client username in Cognito, must be unique. Defaults to a hex hash of their email
	"""
	username: String!
	"""
	The client email, must be unique.
	"""
	email: CiText!
	"""
	The client password salted, peppered, and hashed
	"""
	password: String! @deprecated(reason: "This field is used only to migrate users to Cognito in v2")
	"""
	The client salt used to prevent dictionary attacks on password hashes and keys
	"""
	salt: String!
	"""
	The client role, used to determine what permissions they have. Defaults to None
	"""
	role: UUID @deprecated(reason: "Role is now determined based on cognito group")
	"""
	The client API key, used to authenticate API requests. Defaults to None
	"""
	apikey: String
	"""
	The default currency used to calculate the client's cost basis and returns. Defaults to USD.
	"""
	basisCoinId: UUID!
	"""
	The client's investment experience
	"""
	experience: Int
	"""
	The client's default portfolio to display
	"""
	portfolio: Int
	"""
	The client's account strength, based on actions taken and steps completed
	"""
	strength: Int
	"""
	The client's preferred theme
	"""
	theme: Int
	"""
	The client's default time view, ie 1D, 1W, 1M, 1Y
	"""
	timeframe: String
	"""
	The time-based one-time password secret
	"""
	totp: String @deprecated(reason: "This field is used only to migrate users with totp activated in v1 to Cognito in v2")
	"""
	The time-based one-time password period in seconds
	"""
	totpPeriod: Int @deprecated(reason: "This field is used only to migrate users with totp activated in v1 to Cognito in v2")
	"""
	One-time password tokens that can be used to bypass 2 factor authentication
	"""
	otTokens: [String!] @deprecated(reason: "This field is used only to migrate users with totp activated in v1 to Cognito in v2")
	"""
	A verification code to be used to verify the client's email address
	"""
	verificationCode: UUID
	"""
	The time at which the verification code expires
	"""
	verificationExpiry: DateTime
	"""
	Used to check whether the client has passed certain elements of onboarding. Canonical record in Cognito.
	"""
	verified: Boolean
	"""
	A verification code to be used to reset the client's password
	"""
	forgotCode: UUID @deprecated(reason: "Password reset is now handled by Cognito")
	"""
	The time at which the password reset code expires
	"""
	forgotExpiry: DateTime @deprecated(reason: "Password reset is now handled by Cognito")
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	Whether the client has enabled trading with real money
	"""
	trading: Boolean
	"""
	The user's Stripe customer ID
	"""
	customerId: String @deprecated(reason: "This field was used for Stripe customer ids, now deprecated in favor of Qolo")
	"""
	The user's preferred default Stripe payment method ID
	"""
	defaultPaymentMethod: String @deprecated(reason: "This field was used for Stripe payment methods, now deprecated in favor of Qolo")
	"""
	The date the client's password was last changed
	"""
	passwordAge: DateTime! @deprecated(reason: "Password reset is now handled by Cognito")
	"""
	The user's unique referral code
	"""
	referralCode: String!
	"""
	This field prevents mutations to any models with the associated user_id
	"""
	frozen: Boolean
	"""
	The date the client last logged in
	"""
	lastLogin: DateTime!
	"""
	The preferred home page upon logging in
	"""
	landingPageUrl: String
	"""
	The date the client accepted the services agreement
	"""
	programAgreement: DateTime
	"""
	The unique identifier for the client's marketing campaign acquisition information
	"""
	utmCodeId: UUID
	"""
	The unique identifier for the client's AWS Cognito identity
	"""
	cognitoId: String
	"""
	The unique identifier for the client's selected profile image
	"""
	profileImageId: String
	"""
	The client's chosen nickname
	"""
	nickname: String
	"""
	This field prevents changes to users in the database used solely for internal accounting purposes
	"""
	isInternal: Boolean
	"""
	The date the client's account was deactivated, causes a cascading change to all associated models with this user_id
	"""
	deactivatedAt: DateTime
	"""
	This field flags the user as disqaulified from using certain features
	"""
	isDisqualified: Boolean!
	"""
	This field represents the most recent version of the mobile app the user interacted with
	"""
	mobileAppVersion: String
	assets(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at"]): [Asset!]!
	assetsV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [AssetsV!]!
	balances(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Balance!]!
	balancesV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [BalancesV!]!
	geminiAccounts(where: Where, limit: Int! = 10, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [GeminiAccount!]!
	mxUser(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [MxUser!]!
	orders(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [Order!]!
	fills(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [OrderFill!]!
	payments(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["source_ts_desc"]): [Payment!]!
	personaInquiry(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [PersonaInquiry!]!
	portfolios(where: Where, limit: Int! = 10, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Portfolio!]!
	qoloPerson(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [QoloPerson!]!
	referred(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Referral!]!
	referrals(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Referral!]!
	stacks(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_asc"]): [Stack!]!
	subscription(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["last_paid_at_desc"]): [SubscriptionsV!]!
	suitability(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Suitability!]!
	userDetails(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UserDetail!]!
	userLoginHistory(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [UserLoginHistory!]!
	usersFeatures(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [UsersFeature!]!
	usersNotifications(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [UsersNotification!]!
	providers(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UsersProvider!]!
	usersProvidersV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [UsersProvidersV!]!
	balance(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [UsersV!]!
}

"""
An tracking table to store user agent information, as most customers use ad blockers
"""
type UserAgent {
	"""
	The unique identifier for the user agent
	"""
	uuid: UUID!
	"""
	The user agent string
	"""
	userAgent: String
	"""
	The browser name
	"""
	browserName: String
	"""
	The browser version
	"""
	browserVersion: String
	"""
	The device type, ie mobile, desktop, smart tv
	"""
	deviceType: String
	"""
	The device model, ie pixel 4, pixol 4a, iPhone 12
	"""
	deviceModel: String
	"""
	The device vendor, ie google, apple, samsung
	"""
	deviceVendor: String
	"""
	The browser engine name, ie chromium, blink, gecko
	"""
	engineName: String
	"""
	The browser engine version
	"""
	engineVersion: String
	"""
	The operating system name, ie android, ios, windows
	"""
	osName: String
	"""
	The operating system version
	"""
	osVersion: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	upcomingFeatureSignups(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UpcomingFeatureSignup!]!
	userLoginHistory(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [UserLoginHistory!]!
}

"""
Builder for [`UserAgent`](struct.UserAgent.html).
"""
input UserAgentInput {
	"""
	The unique identifier for the user agent
	"""
	uuid: UUID
	"""
	The user agent string
	"""
	userAgent: String
	"""
	The browser name
	"""
	browserName: String
	"""
	The browser version
	"""
	browserVersion: String
	"""
	The device type, ie mobile, desktop, smart tv
	"""
	deviceType: String
	"""
	The device model, ie pixel 4, pixol 4a, iPhone 12
	"""
	deviceModel: String
	"""
	The device vendor, ie google, apple, samsung
	"""
	deviceVendor: String
	"""
	The browser engine name, ie chromium, blink, gecko
	"""
	engineName: String
	"""
	The browser engine version
	"""
	engineVersion: String
	"""
	The operating system name, ie android, ios, windows
	"""
	osName: String
	"""
	The operating system version
	"""
	osVersion: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

type UserAgentPayload {
	action: String!
	payload: UserAgent
	error: String
}

type UserAssetsGraphCandle {
	sourceTs: String!
	userId: String!
	valueOpenUsd: String!
	valueCloseUsd: String!
	valueLowUsd: String!
	valueHighUsd: String!
}

"""
Builder for [`UserAssetsGraphRequest`](struct.UserAssetsGraphRequest.html).
"""
input UserAssetsGraphRequestInput {
	userId: UUID
	frequency: String
	startDate: String
	endDate: String
}

type UserAssetsGraphResponse {
	userId: UUID!
	frequency: String!
	startDate: String!
	endDate: String!
	candles: [UserAssetsGraphCandle!]!
}

"""
The main user model that connects to all the relevant models.
It is connected to a cognito identity via the user.cognito_id and cognito.sub_id.
"""
type UserDelegate {
	"""
	The unique identifier for the user delegate record
	"""
	uuid: UUID!
	"""
	The user ID who is authorizing a delegate to act on their behalf
	"""
	userId: UUID!
	"""
	The delegate user ID who may act on behalf of another user identified by user_id
	"""
	delegateUserId: UUID!
	"""
	Permissions granted to the delegate
	"""
	permissions: [String!]!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
The user's KYC information necessary to validate their bank account ownership
"""
type UserDetail {
	"""
	The unique identifier for this user detail
	"""
	uuid: UUID!
	"""
	The user's first name
	"""
	firstName: String
	"""
	The user's middle name
	"""
	middleName: String
	"""
	The user's last name
	"""
	lastName: String
	"""
	The user's birthdate
	"""
	birthdate: NaiveDate
	"""
	The unique identifier for the user
	"""
	userId: UUID!
	"""
	The user's zip code
	"""
	usZipCode: String
	"""
	The user's state
	"""
	usState: String
	"""
	The user's country
	"""
	countryId: UUID
	"""
	The user's phone number
	"""
	phoneNumber: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

type UserDetailPayload {
	action: String!
	payload: UserDetail
	error: String
}

"""
Builder for [`User`](struct.User.html).
"""
input UserInput {
	"""
	The unique identifier for the user
	"""
	uuid: UUID
	"""
	The client username in Cognito, must be unique. Defaults to a hex hash of their email
	"""
	username: String
	"""
	The client email, must be unique.
	"""
	email: CiText
	"""
	The client password salted, peppered, and hashed
	"""
	password: String
	"""
	The client salt used to prevent dictionary attacks on password hashes and keys
	"""
	salt: String
	"""
	The client role, used to determine what permissions they have. Defaults to None
	"""
	role: UUID
	"""
	The client API key, used to authenticate API requests. Defaults to None
	"""
	apikey: String
	"""
	The default currency used to calculate the client's cost basis and returns. Defaults to USD.
	"""
	basisCoinId: UUID
	"""
	The client's investment experience
	"""
	experience: Int
	"""
	The client's default portfolio to display
	"""
	portfolio: Int
	"""
	The client's account strength, based on actions taken and steps completed
	"""
	strength: Int
	"""
	The client's preferred theme
	"""
	theme: Int
	"""
	The client's default time view, ie 1D, 1W, 1M, 1Y
	"""
	timeframe: String
	"""
	The time-based one-time password secret
	"""
	totp: String
	"""
	The time-based one-time password period in seconds
	"""
	totpPeriod: Int
	"""
	One-time password tokens that can be used to bypass 2 factor authentication
	"""
	otTokens: [String!]
	"""
	A verification code to be used to verify the client's email address
	"""
	verificationCode: UUID
	"""
	The time at which the verification code expires
	"""
	verificationExpiry: DateTime
	"""
	Used to check whether the client has passed certain elements of onboarding. Canonical record in Cognito.
	"""
	verified: Boolean
	"""
	A verification code to be used to reset the client's password
	"""
	forgotCode: UUID
	"""
	The time at which the password reset code expires
	"""
	forgotExpiry: DateTime
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	Whether the client has enabled trading with real money
	"""
	trading: Boolean
	"""
	The user's Stripe customer ID
	"""
	customerId: String
	"""
	The user's preferred default Stripe payment method ID
	"""
	defaultPaymentMethod: String
	"""
	The date the client's password was last changed
	"""
	passwordAge: DateTime
	"""
	The user's unique referral code
	"""
	referralCode: String
	"""
	This field prevents mutations to any models with the associated user_id
	"""
	frozen: Boolean
	"""
	The date the client last logged in
	"""
	lastLogin: DateTime
	"""
	The preferred home page upon logging in
	"""
	landingPageUrl: String
	"""
	The date the client accepted the services agreement
	"""
	programAgreement: DateTime
	"""
	The unique identifier for the client's marketing campaign acquisition information
	"""
	utmCodeId: UUID
	"""
	The unique identifier for the client's AWS Cognito identity
	"""
	cognitoId: String
	"""
	The unique identifier for the client's selected profile image
	"""
	profileImageId: String
	"""
	The client's chosen nickname
	"""
	nickname: String
	"""
	This field prevents changes to users in the database used solely for internal accounting purposes
	"""
	isInternal: Boolean
	"""
	The date the client's account was deactivated, causes a cascading change to all associated models with this user_id
	"""
	deactivatedAt: DateTime
	"""
	This field flags the user as disqaulified from using certain features
	"""
	isDisqualified: Boolean
	"""
	This field represents the most recent version of the mobile app the user interacted with
	"""
	mobileAppVersion: String
}

"""
The history of logins, used to track suspicious activity
"""
type UserLoginHistory {
	"""
	The unique identifier for this login history
	"""
	uuid: UUID!
	"""
	The unique identifier of the associated user
	"""
	userId: UUID
	"""
	The IP address of the user who logged in
	"""
	ipAddress: String
	"""
	The type of event that occurred
	"""
	eventType: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier of the associated user agent
	"""
	userAgentId: UUID
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
	userAgent(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UserAgent!]!
}

type UserLoginHistoryPayload {
	action: String!
	payload: UserLoginHistory
	error: String
}

type UserPayload {
	action: String!
	payload: User
	error: String
}

"""
A set of feature flags for a user
"""
type UsersFeature {
	"""
	The unique identifier for this user's feature flag
	"""
	uuid: UUID!
	"""
	The unique identifier of the associated user
	"""
	userId: UUID
	"""
	The unique identifier of the associated feature flag
	"""
	featureId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	features(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [Feature!]!
}

"""
Builder for [`UsersFeature`](struct.UsersFeature.html).
"""
input UsersFeatureInput {
	"""
	The unique identifier for this user's feature flag
	"""
	uuid: UUID
	"""
	The unique identifier of the associated user
	"""
	userId: UUID
	"""
	The unique identifier of the associated feature flag
	"""
	featureId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
}

type UsersFeaturePayload {
	action: String!
	payload: UsersFeature
	error: String
}

"""
Connects a user to a set of notifications
"""
type UsersNotification {
	"""
	The unique identifier for this user's notification
	"""
	uuid: UUID!
	"""
	The unique identifier of the associated user
	"""
	userId: UUID
	"""
	The unique identifier of the associated notification
	"""
	notificationId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	notification(where: Where, limit: Int! = 0, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [Notification!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
Builder for [`UsersNotification`](struct.UsersNotification.html).
"""
input UsersNotificationInput {
	"""
	The unique identifier for this user's notification
	"""
	uuid: UUID
	"""
	The unique identifier of the associated user
	"""
	userId: UUID
	"""
	The unique identifier of the associated notification
	"""
	notificationId: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
}

type UsersNotificationPayload {
	action: String!
	payload: UsersNotification
	error: String
}

"""
Connects a user to a provider so they can track it
"""
type UsersProvider {
	"""
	The unique identifier for this user-provider association
	"""
	uuid: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier of the associated provider
	"""
	providerId: UUID!
	"""
	The unique identifier of the associated user
	"""
	userId: UUID!
	"""
	Whether or not the user has hearted the provider
	"""
	isHearted: Boolean!
	"""
	The user's nickname for the provider
	"""
	nickname: String
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
	apikey: [ApiKey!]!
	mxAccount(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [MxAccount!]!
	mxMember(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [MxMember!]!
	provider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [Provider!]!
	qoloOutsideInstrument(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [QoloOutsideInstrument!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
	usersProvidersV(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [UsersProvidersV!]!
}

"""
Builder for [`UsersProvider`](struct.UsersProvider.html).
"""
input UsersProviderInput {
	"""
	The unique identifier for this user-provider association
	"""
	uuid: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The unique identifier of the associated provider
	"""
	providerId: UUID
	"""
	The unique identifier of the associated user
	"""
	userId: UUID
	"""
	Whether or not the user has hearted the provider
	"""
	isHearted: Boolean
	"""
	The user's nickname for the provider
	"""
	nickname: String
	"""
	The date the row was soft-deleted in the database
	"""
	deletedAt: DateTime
}

type UsersProviderPayload {
	action: String!
	payload: UsersProvider
	error: String
}

"""
This model aggregates balances on "user_provider_id" and "coin_id".
E.g., all BTC balances in your Coinbase wallet.
"""
type UsersProvidersAssetsV {
	"""
	The unique identifier for this users_provider-coin view
	"""
	usersProvidersId: UUID
	"""
	The unique identifier for the associated user
	"""
	userId: UUID
	"""
	The unique identifier for the associated provider
	"""
	providerId: UUID
	"""
	The human-readable identifier for the associated provider
	"""
	providerInternalId: String
	"""
	The unique identifier for the associated coin
	"""
	coinId: UUID
	"""
	The human-readable identifier for the associated coin
	"""
	coinInternalId: String
	"""
	The trading symbol generally used for the associated coin
	"""
	coinSymbol: String
	"""
	The coin order for the associated coin
	"""
	coinOrder: Int
	"""
	The total balance of all balances sharing this coin on this user_provider
	"""
	balance: Numeric
	"""
	The total balance of all balances sharing this coin on this user_provider, in USD
	"""
	balanceUsd: Numeric
	"""
	The current USD exchange rate for this coin
	"""
	fxRateUsd: Numeric
	"""
	The total number of balances sharing this coin on this user_provider
	"""
	balanceCount: Int
	"""
	The unique identifiers for all balances sharing this coin on this user_provider
	"""
	balanceIds: [UUID!]
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	provider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [Provider!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
	usersProvider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [UsersProvidersV!]!
}

"""
A view to aggregate the balances that belong to a given users_provider
"""
type UsersProvidersV {
	"""
	The unique identifier for this user provider
	"""
	usersProvidersId: UUID
	"""
	The unique identifier for the associated user
	"""
	userId: UUID
	"""
	The unique identifier for the associated provider
	"""
	providerId: UUID
	"""
	The unique human-readable identifier for the associated provider
	"""
	providerInternalId: String
	"""
	The type of the associated provider, eg exchange, software wallet, hardware wallet
	"""
	providerType: String
	"""
	The unique identifier for the associated provider in MX's database
	"""
	mxId: String
	"""
	Whether or not the associated provider has any associated outside bank accounts or credit cards via Qolo
	"""
	hasQoloOutsideInstruments: Boolean
	"""
	Whether or not the associated provider has any associated MX accounts
	"""
	hasMxAccounts: Boolean
	"""
	The total balance of the associated provider in USD
	"""
	balanceUsd: Numeric
	"""
	The total balance of the associated provider in USD, excluding any balances that come from MX accounts
	"""
	mxExcludedBalanceUsd: Numeric
	"""
	The total balance of the associated provider in USD
	"""
	mxIncludedBalanceUsd: Numeric
	"""
	The total balance of all committed transaction funds in flight
	"""
	committedTxBalanceUsd: Numeric
	"""
	The total balance of all committed order funds in flight
	"""
	committedOrdersBalanceUsd: Numeric
	"""
	The total balance of all free funds for use
	"""
	freeBalanceUsd: Numeric
	"""
	The total number of balances that belong to this users_provider
	"""
	balanceCount: Int
	"""
	The date of the most recent successful API key fetch for this users_provider
	"""
	successAt: DateTime
	apikey: [ApiKey!]!
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
	usersProvider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UsersProvider!]!
	usersProviderAssets(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["balance_usd_desc"]): [UsersProvidersAssetsV!]!
}

"""
A view to collect together the total USD value of all a user's balances
"""
type UsersV {
	"""
	The unique identifier for this user
	"""
	userId: UUID
	"""
	The total USD value of all balances that belong to this user
	"""
	balanceUsd: Numeric
	"""
	The total USD value of all balances that belong to this user, excluding those that are from MX accounts
	"""
	mxExcludedBalanceUsd: Numeric
	"""
	The total USD value of all balances that belong to this user, including those that are from MX accounts
	"""
	mxIncludedBalanceUsd: Numeric
	"""
	The total USD value of all managed balances that belong to this user
	"""
	managedBalanceUsd: Numeric
	"""
	The total USD value of all unmanaged balances that belong to this user
	"""
	unmanagedBalanceUsd: Numeric
	user(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["created_at_desc"]): [User!]!
}

"""
Tracking codes for marketing campaigns a user may have come from
"""
type UtmCode {
	"""
	The unique identifier for this utm code
	"""
	uuid: UUID!
	"""
	The source url of the utm code
	"""
	utmSource: String
	"""
	The ad type
	"""
	utmMedium: String
	"""
	The advertising campaign identifier
	"""
	utmCampaign: String
	"""
	The specific ad copy or image identifier
	"""
	utmContent: String
	"""
	The keyword used to find the ad
	"""
	utmTerm: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	upcomingFeatureSignups(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["updated_at_desc"]): [UpcomingFeatureSignup!]!
}

"""
Builder for [`UtmCode`](struct.UtmCode.html).
"""
input UtmCodeInput {
	"""
	The unique identifier for this utm code
	"""
	uuid: UUID
	"""
	The source url of the utm code
	"""
	utmSource: String
	"""
	The ad type
	"""
	utmMedium: String
	"""
	The advertising campaign identifier
	"""
	utmCampaign: String
	"""
	The specific ad copy or image identifier
	"""
	utmContent: String
	"""
	The keyword used to find the ad
	"""
	utmTerm: String
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
}

"""
Builder for [`ValidateAddressRequest`](struct.ValidateAddressRequest.html).
"""
input ValidateAddressRequestInput {
	address: String
	network: String
	symbol: String
	tag: String
}

type ValidateAddressResponse {
	isValid: Boolean!
	isError: Boolean!
}

"""
A connection between a coin and a provider, representing whether the coin can be stored or tracked there
"""
type Wallet {
	"""
	The unique identifier for this wallet
	"""
	uuid: UUID!
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime!
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime!
	"""
	The unique identifier of the associated coin
	"""
	coinId: UUID
	"""
	The unique identifier of the associated provider
	"""
	providerId: UUID
	"""
	The number of significant figures used when calculating this coin's balance on this provider's platform
	"""
	sigfigsOverride: Int
	"""
	Whether a wallet is listed or delisted on an exchange.
	"""
	isActive: Boolean!
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	provider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [Provider!]!
}

"""
Builder for [`Wallet`](struct.Wallet.html).
"""
input WalletInput {
	"""
	The unique identifier for this wallet
	"""
	uuid: UUID
	"""
	The date the row was created in the database
	"""
	createdAt: DateTime
	"""
	The date the row was last updated in the database
	"""
	updatedAt: DateTime
	"""
	The unique identifier of the associated coin
	"""
	coinId: UUID
	"""
	The unique identifier of the associated provider
	"""
	providerId: UUID
	"""
	The number of significant figures used when calculating this coin's balance on this provider's platform
	"""
	sigfigsOverride: Int
	"""
	Whether a wallet is listed or delisted on an exchange.
	"""
	isActive: Boolean
}

type WalletPayload {
	action: String!
	payload: Wallet
	error: String
}

"""
A view to collect together the internal ids of a connected coin and wallet. This
is used to make searching for specific wallets easier
"""
type WalletsV {
	"""
	The unique identifier for this wallet
	"""
	walletId: UUID
	"""
	The unique identifier for the associated provider
	"""
	providerId: UUID
	"""
	The unique identifier for the associated coin
	"""
	coinId: UUID
	"""
	The number of significant figures to use when displaying this coin on this provider
	"""
	sigfigsOverride: Int
	"""
	The human-readable identifier for the associated provider
	"""
	providerInternalId: String
	"""
	The human-readable identifier for the associated coin
	"""
	coinInternalId: String
	"""
	The type of provider, eg, exchange, software wallet, hardware wallet, dex
	"""
	providerType: String
	"""
	The type of coin, eg, crypto, fiat, stablecoin
	"""
	coinType: String
	"""
	The order in which the coin should be displayed in lists.
	"""
	coinOrder: Int
	"""
	Whether a wallet is listed or delisted on an exchange.
	"""
	isActive: Boolean!
	coin(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["order_asc"]): [Coin!]!
	provider(where: Where, limit: Int! = 100, offset: Int! = 0, orderBy: [String!]! = ["name_asc"]): [Provider!]!
}

scalar Where

type WhitelistedAddress {
	network: String!
	scope: String!
	label: String!
	status: String!
	createdAt: String!
	address: String!
}

"""
Builder for [`WidgetUrlOptions`](struct.WidgetUrlOptions.html).
"""
input WidgetUrlOptionsInput {
	clientRedirectUrl: String
	colorScheme: String
	currentInstitutionCode: String
	currentInstitutionGuid: String
	currentMemberGuid: String
	disableBackgroundAgg: Boolean
	disableInstitutionSearch: Boolean
	includeTransactions: Boolean
	isMobileWebview: Boolean
	mode: String
	oauthReferralSource: String
	uiMessageVersion: Int
	uiMessageWebviewUrlScheme: String
	updateCredentials: Boolean
	waitForFullAggregation: Boolean
	widgetType: String
	includeIdentity: Boolean
}

"""
Builder for [`WidgetUrlRequest`](struct.WidgetUrlRequest.html).
"""
input WidgetUrlRequestInput {
	language: String
	userGuid: String
	options: WidgetUrlOptionsInput!
}

type WidgetUrlResponse {
	type: String!
	url: String!
	userId: String!
}

type WithdrawalResponse {
	address: String!
	amount: String!
	fee: String
	withdrawalId: String
	message: String
}

schema {
	query: Query
	mutation: Mutation
	subscription: Subscription
}
